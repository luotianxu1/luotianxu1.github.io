import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as h,c as d,a,d as l,b as r,e as t,w as s}from"./app-BZCNBBDt.js";const m={};function c(u,e){const o=i("IFrame"),n=i("RouteLink");return h(),d("div",null,[e[5]||(e[5]=a("h2",{id:"meshstandardmaterial",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#meshstandardmaterial"},[a("span",null,"MeshStandardMaterial")])],-1)),e[6]||(e[6]=a("p",null,"一种基于物理的标准材质，使用Metallic-Roughness工作流程。",-1)),e[7]||(e[7]=a("p",null,"基于物理的渲染（PBR）最近已成为许多3D应用程序的标准，例如Unity， Unreal和 3D Studio Max。",-1)),e[8]||(e[8]=a("p",null,"这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。 我们的想法是，不是在特定照明下调整材质以使其看起来很好，而是可以创建一种材质，能够“正确”地应对所有光照场景。",-1)),e[9]||(e[9]=a("p",null,"在实践中，该材质提供了比MeshLambertMaterial 或MeshPhongMaterial 更精确和逼真的结果，代价是计算成本更高。",-1)),e[10]||(e[10]=a("p",null,"请注意，为获得最佳效果，您在使用此材质时应始终指定environment map。",-1)),l(o,{url:"https://luotainxu-demo.netlify.app/#/threejs/material/meshStandardMaterial"}),e[11]||(e[11]=r('<h2 id="构造器" tabindex="-1"><a class="header-anchor" href="#构造器"><span>构造器</span></a></h2><h3 id="parameters-object" tabindex="-1"><a class="header-anchor" href="#parameters-object"><span>parameters : Object</span></a></h3><p>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从Material继承的任何属性)。</p><p>属性color例外，其可以作为十六进制字符串传递，默认情况下为 0xffffff（白色），内部调用Color.set(color)。</p><h2 id="属性" tabindex="-1"><a class="header-anchor" href="#属性"><span>属性</span></a></h2>',5)),a("p",null,[e[1]||(e[1]=t("共有属性请参见其基类")),l(n,{to:"/threejs/%E6%9D%90%E8%B4%A8/%E6%9D%90%E8%B4%A8.html"},{default:s(()=>e[0]||(e[0]=[t("Material")])),_:1}),e[2]||(e[2]=t("。"))]),e[12]||(e[12]=r('<h3 id="alphamap-texture" tabindex="-1"><a class="header-anchor" href="#alphamap-texture"><span>.alphaMap : Texture</span></a></h3><p>alpha贴图是一张灰度纹理，用于控制整个表面的不透明度。（黑色：完全透明；白色：完全不透明）。 默认值为null。</p><p>仅使用纹理的颜色，忽略alpha通道（如果存在）。 对于RGB和RGBA纹理，WebGL渲染器在采样此纹理时将使用绿色通道， 因为在DXT压缩和未压缩RGB 565格式中为绿色提供了额外的精度。 Luminance-only以及luminance/alpha纹理也仍然有效。</p><h3 id="aomap-texture" tabindex="-1"><a class="header-anchor" href="#aomap-texture"><span>.aoMap : Texture</span></a></h3><p>该纹理的红色通道用作环境遮挡贴图。默认值为null。aoMap需要第二组UV。</p><h3 id="aomapintensity-float" tabindex="-1"><a class="header-anchor" href="#aomapintensity-float"><span>.aoMapIntensity : Float</span></a></h3><p>环境遮挡效果的强度。默认值为1。零是不遮挡效果。</p><h3 id="bumpmap-texture" tabindex="-1"><a class="header-anchor" href="#bumpmap-texture"><span>.bumpMap : Texture</span></a></h3><p>用于创建凹凸贴图的纹理。黑色和白色值映射到与光照相关的感知深度。凹凸实际上不会影响对象的几何形状，只影响光照。如果定义了法线贴图，则将忽略该贴图。</p><h3 id="bumpscale-float" tabindex="-1"><a class="header-anchor" href="#bumpscale-float"><span>.bumpScale : Float</span></a></h3><p>凹凸贴图会对材质产生多大影响。典型范围是0-1。默认值为1。</p><h3 id="color-color" tabindex="-1"><a class="header-anchor" href="#color-color"><span>.color : Color</span></a></h3><p>材质的颜色(Color)，默认值为白色 (0xffffff)。</p><h3 id="defines-object" tabindex="-1"><a class="header-anchor" href="#defines-object"><span>.defines : Object</span></a></h3><p>如下形式的对象:</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;STANDARD&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>WebGLRenderer使用它来选择shaders。</p><h3 id="displacementmap-texture" tabindex="-1"><a class="header-anchor" href="#displacementmap-texture"><span>.displacementMap : Texture</span></a></h3><p>位移贴图会影响网格顶点的位置，与仅影响材质的光照和阴影的其他贴图不同，移位的顶点可以投射阴影，阻挡其他对象， 以及充当真实的几何体。位移纹理是指：网格的所有顶点被映射为图像中每个像素的值（白色是最高的），并且被重定位。</p><h3 id="displacementscale-float" tabindex="-1"><a class="header-anchor" href="#displacementscale-float"><span>.displacementScale : Float</span></a></h3><p>位移贴图对网格的影响程度（黑色是无位移，白色是最大位移）。如果没有设置位移贴图，则不会应用此值。默认值为1。</p><h3 id="displacementbias-float" tabindex="-1"><a class="header-anchor" href="#displacementbias-float"><span>.displacementBias : Float</span></a></h3><p>位移贴图在网格顶点上的偏移量。如果没有设置位移贴图，则不会应用此值。默认值为0。</p><h3 id="emissive-color" tabindex="-1"><a class="header-anchor" href="#emissive-color"><span>.emissive : Color</span></a></h3><p>材质的放射（光）颜色，基本上是不受其他光照影响的固有颜色。默认为黑色。</p><h3 id="emissivemap-texture" tabindex="-1"><a class="header-anchor" href="#emissivemap-texture"><span>.emissiveMap : Texture</span></a></h3><p>设置放射（发光）贴图。默认值为null。放射贴图颜色由放射颜色和强度所调节。 如果你有一个放射贴图，请务必将放射颜色设置为黑色以外的其他颜色。</p><h3 id="emissiveintensity-float" tabindex="-1"><a class="header-anchor" href="#emissiveintensity-float"><span>.emissiveIntensity : Float</span></a></h3><p>放射光强度。调节发光颜色。默认为1。</p><h3 id="envmap-texture" tabindex="-1"><a class="header-anchor" href="#envmap-texture"><span>.envMap : Texture</span></a></h3><p>环境贴图，为了能够保证物理渲染准确，您应该添加由PMREMGenerator预处理过的环境贴图，默认为null。</p><h3 id="envmapintensity-float" tabindex="-1"><a class="header-anchor" href="#envmapintensity-float"><span>.envMapIntensity : Float</span></a></h3><p>通过乘以环境贴图的颜色来缩放环境贴图的效果。</p><h3 id="flatshading-boolean" tabindex="-1"><a class="header-anchor" href="#flatshading-boolean"><span>.flatShading : Boolean</span></a></h3><p>定义材质是否使用平面着色进行渲染。默认值为false。</p><h3 id="fog-boolean" tabindex="-1"><a class="header-anchor" href="#fog-boolean"><span>.fog : Boolean</span></a></h3><p>材质是否受雾影响。默认为true。</p><h3 id="ismeshstandardmaterial-boolean" tabindex="-1"><a class="header-anchor" href="#ismeshstandardmaterial-boolean"><span>.isMeshStandardMaterial : Boolean</span></a></h3><p>检查当前对象是否为标准网格材质的标记。</p><h3 id="lightmap-texture" tabindex="-1"><a class="header-anchor" href="#lightmap-texture"><span>.lightMap : Texture</span></a></h3><p>光照贴图。默认值为null。lightMap需要第二组UV。</p><h3 id="lightmapintensity-float" tabindex="-1"><a class="header-anchor" href="#lightmapintensity-float"><span>.lightMapIntensity : Float</span></a></h3><p>烘焙光的强度。默认值为1。</p><h3 id="map-texture" tabindex="-1"><a class="header-anchor" href="#map-texture"><span>.map : Texture</span></a></h3><p>颜色贴图。可以选择包括一个alpha通道，通常与.transparent 或.alphaTest。默认为null。 纹理贴图颜色由漫反射颜色.color调节。</p><h3 id="metalness-float" tabindex="-1"><a class="header-anchor" href="#metalness-float"><span>.metalness : Float</span></a></h3><p>材质与金属的相似度。非金属材质，如木材或石材，使用0.0，金属使用1.0，通常没有中间值。 默认值为0.0。0.0到1.0之间的值可用于生锈金属的外观。如果还提供了metalnessMap，则两个值相乘。</p><h3 id="metalnessmap-texture" tabindex="-1"><a class="header-anchor" href="#metalnessmap-texture"><span>.metalnessMap : Texture</span></a></h3><p>该纹理的蓝色通道用于改变材质的金属度。</p><h3 id="normalmap-texture" tabindex="-1"><a class="header-anchor" href="#normalmap-texture"><span>.normalMap : Texture</span></a></h3><p>用于创建法线贴图的纹理。RGB值会影响每个像素片段的曲面法线，并更改颜色照亮的方式。法线贴图不会改变曲面的实际形状，只会改变光照。 In case the material has a normal map authored using the left handed convention, the y component of normalScale should be negated to compensate for the different handedness.</p><h3 id="normalmaptype-integer" tabindex="-1"><a class="header-anchor" href="#normalmaptype-integer"><span>.normalMapType : Integer</span></a></h3><p>法线贴图的类型。</p><p>选项为THREE.TangentSpaceNormalMap（默认）和THREE.ObjectSpaceNormalMap。</p><h3 id="normalscale-vector2" tabindex="-1"><a class="header-anchor" href="#normalscale-vector2"><span>.normalScale : Vector2</span></a></h3><p>法线贴图对材质的影响程度。典型范围是0-1。默认值是Vector2设置为（1,1）。</p><h3 id="refractionratio-float" tabindex="-1"><a class="header-anchor" href="#refractionratio-float"><span>.refractionRatio : Float</span></a></h3><p>空气的折射率（IOR）（约为1）除以材质的折射率。它与环境映射模式THREE.CubeRefractionMapping 和THREE.EquirectangularRefractionMapping一起使用。 The index of refraction (IOR) of air (approximately 1) divided by the index of refraction of the material. It is used with environment mapping mode THREE.CubeRefractionMapping. 折射率不应超过1。默认值为0.98。</p><h3 id="roughness-float" tabindex="-1"><a class="header-anchor" href="#roughness-float"><span>.roughness : Float</span></a></h3><p>材质的粗糙程度。0.0表示平滑的镜面反射，1.0表示完全漫反射。默认值为1.0。如果还提供roughnessMap，则两个值相乘。</p><h3 id="roughnessmap-texture" tabindex="-1"><a class="header-anchor" href="#roughnessmap-texture"><span>.roughnessMap : Texture</span></a></h3><p>该纹理的绿色通道用于改变材质的粗糙度。</p><h3 id="wireframe-boolean" tabindex="-1"><a class="header-anchor" href="#wireframe-boolean"><span>.wireframe : Boolean</span></a></h3><p>将几何体渲染为线框。默认值为false（即渲染为平面多边形）。</p><h3 id="wireframelinecap-string" tabindex="-1"><a class="header-anchor" href="#wireframelinecap-string"><span>.wireframeLinecap : String</span></a></h3><p>定义线两端的外观。可选值为 &#39;butt&#39;，&#39;round&#39; 和 &#39;square&#39;。默认为&#39;round&#39;。</p><p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p><h3 id="wireframelinejoin-string" tabindex="-1"><a class="header-anchor" href="#wireframelinejoin-string"><span>.wireframeLinejoin : String</span></a></h3><p>定义线连接节点的样式。可选值为 &#39;round&#39;, &#39;bevel&#39; 和 &#39;miter&#39;。默认值为 &#39;round&#39;。</p><p>该属性对应2D Canvas lineJoin属性， 并且会被WebGL渲染器忽略。</p><h3 id="wireframelinewidth-float" tabindex="-1"><a class="header-anchor" href="#wireframelinewidth-float"><span>.wireframeLinewidth : Float</span></a></h3><p>控制线框宽度。默认值为1。</p><p>由于OpenGL Core Profile与大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。</p><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法"><span>方法</span></a></h2>',74)),a("p",null,[e[4]||(e[4]=t("共有方法请参见其基类")),l(n,{to:"/threejs/%E6%9D%90%E8%B4%A8/%E6%9D%90%E8%B4%A8.html"},{default:s(()=>e[3]||(e[3]=[t("Material")])),_:1})])])}const x=p(m,[["render",c],["__file","标准网格材质.html.vue"]]),b=JSON.parse('{"path":"/threejs/%E6%9D%90%E8%B4%A8/%E6%A0%87%E5%87%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8.html","title":"MeshStandardMaterial(标准网格材质)","lang":"zh-CN","frontmatter":{"title":"MeshStandardMaterial(标准网格材质)","icon":"markdown","order":11,"date":"2023-03-13T00:00:00.000Z","category":["threejs"],"tag":["材质"],"description":"MeshStandardMaterial 一种基于物理的标准材质，使用Metallic-Roughness工作流程。 基于物理的渲染（PBR）最近已成为许多3D应用程序的标准，例如Unity， Unreal和 3D Studio Max。 这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。 我们的想法是，不...","head":[["meta",{"property":"og:url","content":"https://luotianxu1.github.io/threejs/%E6%9D%90%E8%B4%A8/%E6%A0%87%E5%87%86%E7%BD%91%E6%A0%BC%E6%9D%90%E8%B4%A8.html"}],["meta",{"property":"og:title","content":"MeshStandardMaterial(标准网格材质)"}],["meta",{"property":"og:description","content":"MeshStandardMaterial 一种基于物理的标准材质，使用Metallic-Roughness工作流程。 基于物理的渲染（PBR）最近已成为许多3D应用程序的标准，例如Unity， Unreal和 3D Studio Max。 这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。 我们的想法是，不..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T09:24:37.000Z"}],["meta",{"property":"article:author","content":"罗天旭"}],["meta",{"property":"article:tag","content":"材质"}],["meta",{"property":"article:published_time","content":"2023-03-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T09:24:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MeshStandardMaterial(标准网格材质)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-13T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-11T09:24:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"罗天旭\\",\\"url\\":\\"https://luotianxu1.github.io\\",\\"email\\":\\"1265062404@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"MeshStandardMaterial","slug":"meshstandardmaterial","link":"#meshstandardmaterial","children":[]},{"level":2,"title":"构造器","slug":"构造器","link":"#构造器","children":[{"level":3,"title":"parameters : Object","slug":"parameters-object","link":"#parameters-object","children":[]}]},{"level":2,"title":"属性","slug":"属性","link":"#属性","children":[{"level":3,"title":".alphaMap : Texture","slug":"alphamap-texture","link":"#alphamap-texture","children":[]},{"level":3,"title":".aoMap : Texture","slug":"aomap-texture","link":"#aomap-texture","children":[]},{"level":3,"title":".aoMapIntensity : Float","slug":"aomapintensity-float","link":"#aomapintensity-float","children":[]},{"level":3,"title":".bumpMap : Texture","slug":"bumpmap-texture","link":"#bumpmap-texture","children":[]},{"level":3,"title":".bumpScale : Float","slug":"bumpscale-float","link":"#bumpscale-float","children":[]},{"level":3,"title":".color : Color","slug":"color-color","link":"#color-color","children":[]},{"level":3,"title":".defines : Object","slug":"defines-object","link":"#defines-object","children":[]},{"level":3,"title":".displacementMap : Texture","slug":"displacementmap-texture","link":"#displacementmap-texture","children":[]},{"level":3,"title":".displacementScale : Float","slug":"displacementscale-float","link":"#displacementscale-float","children":[]},{"level":3,"title":".displacementBias : Float","slug":"displacementbias-float","link":"#displacementbias-float","children":[]},{"level":3,"title":".emissive : Color","slug":"emissive-color","link":"#emissive-color","children":[]},{"level":3,"title":".emissiveMap : Texture","slug":"emissivemap-texture","link":"#emissivemap-texture","children":[]},{"level":3,"title":".emissiveIntensity : Float","slug":"emissiveintensity-float","link":"#emissiveintensity-float","children":[]},{"level":3,"title":".envMap : Texture","slug":"envmap-texture","link":"#envmap-texture","children":[]},{"level":3,"title":".envMapIntensity : Float","slug":"envmapintensity-float","link":"#envmapintensity-float","children":[]},{"level":3,"title":".flatShading : Boolean","slug":"flatshading-boolean","link":"#flatshading-boolean","children":[]},{"level":3,"title":".fog : Boolean","slug":"fog-boolean","link":"#fog-boolean","children":[]},{"level":3,"title":".isMeshStandardMaterial : Boolean","slug":"ismeshstandardmaterial-boolean","link":"#ismeshstandardmaterial-boolean","children":[]},{"level":3,"title":".lightMap : Texture","slug":"lightmap-texture","link":"#lightmap-texture","children":[]},{"level":3,"title":".lightMapIntensity : Float","slug":"lightmapintensity-float","link":"#lightmapintensity-float","children":[]},{"level":3,"title":".map : Texture","slug":"map-texture","link":"#map-texture","children":[]},{"level":3,"title":".metalness : Float","slug":"metalness-float","link":"#metalness-float","children":[]},{"level":3,"title":".metalnessMap : Texture","slug":"metalnessmap-texture","link":"#metalnessmap-texture","children":[]},{"level":3,"title":".normalMap : Texture","slug":"normalmap-texture","link":"#normalmap-texture","children":[]},{"level":3,"title":".normalMapType : Integer","slug":"normalmaptype-integer","link":"#normalmaptype-integer","children":[]},{"level":3,"title":".normalScale : Vector2","slug":"normalscale-vector2","link":"#normalscale-vector2","children":[]},{"level":3,"title":".refractionRatio : Float","slug":"refractionratio-float","link":"#refractionratio-float","children":[]},{"level":3,"title":".roughness : Float","slug":"roughness-float","link":"#roughness-float","children":[]},{"level":3,"title":".roughnessMap : Texture","slug":"roughnessmap-texture","link":"#roughnessmap-texture","children":[]},{"level":3,"title":".wireframe : Boolean","slug":"wireframe-boolean","link":"#wireframe-boolean","children":[]},{"level":3,"title":".wireframeLinecap : String","slug":"wireframelinecap-string","link":"#wireframelinecap-string","children":[]},{"level":3,"title":".wireframeLinejoin : String","slug":"wireframelinejoin-string","link":"#wireframelinejoin-string","children":[]},{"level":3,"title":".wireframeLinewidth : Float","slug":"wireframelinewidth-float","link":"#wireframelinewidth-float","children":[]}]},{"level":2,"title":"方法","slug":"方法","link":"#方法","children":[]}],"git":{"createdTime":1726046677000,"updatedTime":1726046677000,"contributors":[{"name":"罗天旭","email":"1265062404@qq.com","commits":1}]},"readingTime":{"minutes":5.59,"words":1678},"filePathRelative":"threejs/材质/标准网格材质.md","localizedDate":"2023年3月13日","excerpt":"<h2>MeshStandardMaterial</h2>\\n<p>一种基于物理的标准材质，使用Metallic-Roughness工作流程。</p>\\n<p>基于物理的渲染（PBR）最近已成为许多3D应用程序的标准，例如Unity， Unreal和 3D Studio Max。</p>\\n<p>这种方法与旧方法的不同之处在于，不使用近似值来表示光与表面的相互作用，而是使用物理上正确的模型。 我们的想法是，不是在特定照明下调整材质以使其看起来很好，而是可以创建一种材质，能够“正确”地应对所有光照场景。</p>\\n<p>在实践中，该材质提供了比MeshLambertMaterial 或MeshPhongMaterial 更精确和逼真的结果，代价是计算成本更高。</p>","autoDesc":true}');export{x as comp,b as data};
