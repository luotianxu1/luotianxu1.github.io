import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as s,b as t}from"./app-DcxFpXjN.js";const l={};function n(r,e){return a(),s("div",null,e[0]||(e[0]=[t(`<h2 id="shadermaterial" tabindex="-1"><a class="header-anchor" href="#shadermaterial"><span>ShaderMaterial</span></a></h2><p>使用自定义 shader 渲染的材质。 shader 是一个用 GLSL 编写的小程序 ，在 GPU 上运行。 您可能需要使用自定义 shader，如果你要：</p><ul><li>要实现内置 materials 之外的效果。</li><li>将许多对象组合成单个 BufferGeometry 以提高性能。</li></ul><p>使用 ShaderMaterial 时需要注意以下注意事项：</p><ul><li>ShaderMaterial 只有使用 WebGLRenderer 才可以绘制正常， 因为 vertexShader 和 fragmentShader 属性中 GLSL 代码必须使用 WebGL 来编译并运行在 GPU 中。</li><li>从 THREE r72 开始，不再支持在 ShaderMaterial 中直接分配属性。 必须使用 BufferGeometry 实例，使用 BufferAttribute 实例来定义自定义属性。</li><li>从 THREE r77 开始，WebGLRenderTarget 或 WebGLCubeRenderTarget 实例不再被用作 uniforms。 必须使用它们的 texture 属性。</li><li>内置 attributes 和 uniforms 与代码一起传递到 shaders。 如果您不希望 WebGLProgram 向 shader 代码添加任何内容，则可以使用 RawShaderMaterial 而不是此类。</li><li>您可以使用指令#pragma unroll_loop_start，#pragma unroll_loop_end 以便通过 shader 预处理器在 GLSL 中展开 for 循环。 该指令必须放在循环的正上方。循环格式必须与定义的标准相对应。 <ul><li>循环必须标准化 normalized。</li><li>循环变量必须是 i。</li></ul></li></ul><h2 id="顶点着色器和片元着色器" tabindex="-1"><a class="header-anchor" href="#顶点着色器和片元着色器"><span>顶点着色器和片元着色器</span></a></h2><p>您可以为每种材质指定两种不同类型的 shaders：</p><ul><li>顶点着色器首先运行; 它接收 attributes， 计算/操纵每个单独顶点的位置，并将其他数据（varyings）传递给片元着色器。</li><li>片元（或像素）着色器后运行; 它设置渲染到屏幕的每个单独的“片元”（像素）的颜色。</li></ul><p>shader 中有三种类型的变量: uniforms, attributes, 和 varyings:</p><ul><li>Uniforms 是所有顶点都具有相同的值的变量。 比如灯光，雾，和阴影贴图就是被储存在 uniforms 中的数据。 uniforms 可以通过顶点着色器和片元着色器来访问。</li><li>Attributes 与每个顶点关联的变量。例如，顶点位置，法线和顶点颜色都是存储在 attributes 中的数据。attributes 只 可以在顶点着色器中访问。</li><li>Varyings 是从顶点着色器传递到片元着色器的变量。对于每一个片元，每一个 varying 的值将是相邻顶点值的平滑插值。</li></ul><p>注意：在 shader 内部，uniforms 和 attributes 就像常量；你只能使用 JavaScript 代码通过缓冲区来修改它们的值。</p><h2 id="内置-attributes-和-uniforms" tabindex="-1"><a class="header-anchor" href="#内置-attributes-和-uniforms"><span>内置 attributes 和 uniforms</span></a></h2><p>WebGLRenderer 默认情况下为 shader 提供了许多 attributes 和 uniforms； 这些变量定义在 shader 程序编译时被自动添加到<em>片元着色器</em>和<em>顶点着色器</em>代码的前面，你不需要自己声明它们。 这些变量的描述请参见 WebGLProgram。</p><p>这些 uniforms 或 attributes（例如，那些和照明，雾等相关的）要求属性设置在材质上， 以便 WebGLRenderer 来拷贝合适的值到 GPU 中。 如果你想在自己的 shader 中使用这些功能，请确保设置这些标志。</p><p>如果你不希望 WebGLProgram 向你的 shader 代码中添加任何东西， 你可以使用 RawShaderMaterial 而不是这个类。</p><h2 id="自定义-attributes-和-uniforms" tabindex="-1"><a class="header-anchor" href="#自定义-attributes-和-uniforms"><span>自定义 attributes 和 uniforms</span></a></h2><p>自定义 attributes 和 uniforms 必须在 GLSL 着色器代码中声明（在 vertexShader 和/或 fragmentShader 中)。 自定义 uniforms 必须定义为 ShaderMaterial 的 uniforms 属性， 而任何自定义 attributes 必须通过 BufferAttribute 实例来定义。 注意 varyings 只需要在 shader 代码中声明（而不必在材质中）。</p><p>要声明一个自定义属性，更多细节请参考 BufferGeometry 页面， 以及 BufferAttribute 页面关于 BufferAttribute 接口。</p><p>当创建 attributes 时，您创建的用来保存属性数据的每个类型化数组（typed array）必须是您的数据类型大小的倍数。 比如，如果你的属性是一个 THREE.Vector3 类型，并且在你的缓存几何模型 BufferGeometry 中有 3000 个顶点， 那么你的类型化数组的长度必须是 3000 * 3，或者 9000（一个顶点一个值）。每个数据类型的尺寸如下表所示：</p><table><thead><tr><th style="text-align:left;">GLSL 类型</th><th style="text-align:center;">JavaScript 类型</th><th style="text-align:center;">尺寸</th></tr></thead><tbody><tr><td style="text-align:left;">float</td><td style="text-align:center;">Number</td><td style="text-align:center;">1</td></tr><tr><td style="text-align:left;">vec2</td><td style="text-align:center;">THREE.Vector2</td><td style="text-align:center;">2</td></tr><tr><td style="text-align:left;">vec3</td><td style="text-align:center;">THREE.Vector3</td><td style="text-align:center;">3</td></tr><tr><td style="text-align:left;">vec3</td><td style="text-align:center;">THREE.Color 3</td><td style="text-align:center;">3</td></tr><tr><td style="text-align:left;">vec4</td><td style="text-align:center;">THREE.Vector4</td><td style="text-align:center;">4</td></tr></tbody></table><p>请注意，属性缓冲区 不会 在其值更改时自动刷新。要更新自定义属性， 需要在模型的 BufferAttribute 中设置 needsUpdate 为 true。</p><p>要声明一个自定义的 Uniform，使用 uniforms 属性：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">uniforms</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> time</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: { </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> },</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> resolution</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: { </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> THREE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Vector2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Object3D.onBeforeRender 中，建议根据 object 和 camera 来更新自定义 Uniform 的值。 因为 Material 可以被 meshes，Scene 的 matrixWorld 以及 Camera 共享， 会在 WebGLRenderer.render 中更新，并会对拥有私有 cameras 的 scene 的渲染造成影响。</p><h2 id="构造器" tabindex="-1"><a class="header-anchor" href="#构造器"><span>构造器</span></a></h2><h3 id="parameters-object" tabindex="-1"><a class="header-anchor" href="#parameters-object"><span>parameters : Object</span></a></h3><p>parameters - (可选)用于定义材质外观的对象，具有一个或多个属性。 材质的任何属性都可以从此处传入(包括从 Material 继承的任何属性)。</p><h2 id="属性" tabindex="-1"><a class="header-anchor" href="#属性"><span>属性</span></a></h2><p>共有属性请参见其基类 Material。</p><h3 id="clipping-boolean" tabindex="-1"><a class="header-anchor" href="#clipping-boolean"><span>.clipping : Boolean</span></a></h3><p>定义此材质是否支持剪裁; 如果渲染器传递clippingPlanes uniform，则为true。默认值为false。</p><h3 id="defaultattributevalues-object" tabindex="-1"><a class="header-anchor" href="#defaultattributevalues-object"><span>.defaultAttributeValues : Object</span></a></h3><p>当渲染的几何体不包含这些属性但材质包含这些属性时，这些默认值将传递给shaders。这可以避免在缓冲区数据丢失时出错。</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">defaultAttributeValues</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;color&#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [ </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ],</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;uv&#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [ </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ],</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;uv2&#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [ </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ]</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="defines-object" tabindex="-1"><a class="header-anchor" href="#defines-object"><span>.defines : Object</span></a></h3><p>使用 #define 指令在GLSL代码为顶点着色器和片段着色器定义自定义常量；每个键/值对产生一行定义语句：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">defines</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> FOO</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">15</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> BAR</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">true</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这将在GLSL代码中产生如下定义语句：</p><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#define FOO 15</span></span>
<span class="line"><span>#define BAR true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="extensions-object" tabindex="-1"><a class="header-anchor" href="#extensions-object"><span>.extensions : Object</span></a></h3><p>一个有如下属性的对象：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">extensions</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> derivatives</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// set to use derivatives</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> fragDepth</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// set to use fragment depth values</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> drawBuffers</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">// set to use draw buffers</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> shaderTextureLOD</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> // set to use shader texture LOD</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="fog-boolean" tabindex="-1"><a class="header-anchor" href="#fog-boolean"><span>.fog : Boolean</span></a></h3><p>定义材质颜色是否受全局雾设置的影响; 如果将fog uniforms传递给shader，则为true。默认值为false。</p><h3 id="fragmentshader-string" tabindex="-1"><a class="header-anchor" href="#fragmentshader-string"><span>.fragmentShader : String</span></a></h3><p>片元着色器的GLSL代码。这是shader程序的实际代码。在上面的例子中， vertexShader 和 fragmentShader 代码是从DOM（HTML文档）中获取的； 它也可以作为一个字符串直接传递或者通过AJAX加载。</p><h3 id="glslversion-string" tabindex="-1"><a class="header-anchor" href="#glslversion-string"><span>.glslVersion : String</span></a></h3><p>Defines the GLSL version of custom shader code. Only relevant for WebGL 2 in order to define whether to specify GLSL 3.0 or not. Valid values are THREE.GLSL1 or THREE.GLSL3. Default is null.</p><h3 id="index0attributename-string" tabindex="-1"><a class="header-anchor" href="#index0attributename-string"><span>.index0AttributeName : String</span></a></h3><p>如果设置，则调用gl.bindAttribLocation 将通用顶点索引绑定到属性变量。默认值未定义。</p><h3 id="isshadermaterial-boolean" tabindex="-1"><a class="header-anchor" href="#isshadermaterial-boolean"><span>.isShaderMaterial : Boolean</span></a></h3><p>Read-only flag to check if a given object is of type ShaderMaterial.</p><h3 id="lights-boolean" tabindex="-1"><a class="header-anchor" href="#lights-boolean"><span>.lights : Boolean</span></a></h3><p>材质是否受到光照的影响。默认值为 false。如果传递与光照相关的uniform数据到这个材质，则为true。默认是false。</p><h3 id="linewidth-float" tabindex="-1"><a class="header-anchor" href="#linewidth-float"><span>.linewidth : Float</span></a></h3><p>控制线框宽度。默认值为1。</p><p>由于OpenGL Core Profile与大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。</p><h3 id="flatshading-boolean" tabindex="-1"><a class="header-anchor" href="#flatshading-boolean"><span>.flatShading : Boolean</span></a></h3><p>定义材质是否使用平面着色进行渲染。默认值为false。</p><h3 id="uniforms-object" tabindex="-1"><a class="header-anchor" href="#uniforms-object"><span>.uniforms : Object</span></a></h3><p>如下形式的对象：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;uniform1&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;uniform2&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>指定要传递给shader代码的uniforms；键为uniform的名称，值(value)是如下形式：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">value</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这里 value 是uniform的值。名称必须匹配 uniform 的name，和GLSL代码中的定义一样。 注意，uniforms逐帧被刷新，所以更新uniform值将立即更新GLSL代码中的相应值。</p><h3 id="uniformsneedupdate-boolean" tabindex="-1"><a class="header-anchor" href="#uniformsneedupdate-boolean"><span>.uniformsNeedUpdate : Boolean</span></a></h3><p>Can be used to force a uniform update while changing uniforms in Object3D.onBeforeRender(). Default is false.</p><h3 id="vertexcolors-boolean" tabindex="-1"><a class="header-anchor" href="#vertexcolors-boolean"><span>.vertexColors : Boolean</span></a></h3><p>定义是否使用顶点着色。默认为false。</p><h3 id="vertexshader-string" tabindex="-1"><a class="header-anchor" href="#vertexshader-string"><span>.vertexShader : String</span></a></h3><p>顶点着色器的GLSL代码。这是shader程序的实际代码。 在上面的例子中，vertexShader 和 fragmentShader 代码是从DOM（HTML文档）中获取的； 它也可以作为一个字符串直接传递或者通过AJAX加载。</p><h3 id="wireframe-boolean" tabindex="-1"><a class="header-anchor" href="#wireframe-boolean"><span>.wireframe : Boolean</span></a></h3><p>将几何体渲染为线框(通过GL_LINES而不是GL_TRIANGLES)。默认值为false（即渲染为平面多边形）。</p><h3 id="wireframelinewidth-float" tabindex="-1"><a class="header-anchor" href="#wireframelinewidth-float"><span>.wireframeLinewidth : Float</span></a></h3><p>控制线框宽度。默认值为1。</p><p>由于OpenGL Core Profile与大多数平台上WebGL渲染器的限制，无论如何设置该值，线宽始终为1。</p><h2 id="方法" tabindex="-1"><a class="header-anchor" href="#方法"><span>方法</span></a></h2><p>共有方法请参见其基类Material。</p><h3 id="clone-shadermaterial-this-shadermaterial" tabindex="-1"><a class="header-anchor" href="#clone-shadermaterial-this-shadermaterial"><span>.clone () : ShaderMaterial this : ShaderMaterial</span></a></h3><p>创建该材质的一个浅拷贝。需要注意的是，vertexShader和fragmentShader使用引用拷贝； attributes的定义也是如此; 这意味着，克隆的材质将共享相同的编译WebGLProgram； 但是，uniforms 是 值拷贝，这样对不同的材质我们可以有不同的uniforms变量。</p>`,80)]))}const p=i(l,[["render",n],["__file","着色器材质.html.vue"]]),o=JSON.parse('{"path":"/threejs/%E6%9D%90%E8%B4%A8/%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8.html","title":"ShaderMaterial(着色器材质)","lang":"zh-CN","frontmatter":{"title":"ShaderMaterial(着色器材质)","icon":"markdown","order":14,"date":"2023-03-13T00:00:00.000Z","category":["threejs"],"tag":["材质"],"description":"ShaderMaterial 使用自定义 shader 渲染的材质。 shader 是一个用 GLSL 编写的小程序 ，在 GPU 上运行。 您可能需要使用自定义 shader，如果你要： 要实现内置 materials 之外的效果。 将许多对象组合成单个 BufferGeometry 以提高性能。 使用 ShaderMaterial 时需要注意以下注...","head":[["meta",{"property":"og:url","content":"https://luotianxu1.github.io/threejs/%E6%9D%90%E8%B4%A8/%E7%9D%80%E8%89%B2%E5%99%A8%E6%9D%90%E8%B4%A8.html"}],["meta",{"property":"og:title","content":"ShaderMaterial(着色器材质)"}],["meta",{"property":"og:description","content":"ShaderMaterial 使用自定义 shader 渲染的材质。 shader 是一个用 GLSL 编写的小程序 ，在 GPU 上运行。 您可能需要使用自定义 shader，如果你要： 要实现内置 materials 之外的效果。 将许多对象组合成单个 BufferGeometry 以提高性能。 使用 ShaderMaterial 时需要注意以下注..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T09:24:37.000Z"}],["meta",{"property":"article:author","content":"罗天旭"}],["meta",{"property":"article:tag","content":"材质"}],["meta",{"property":"article:published_time","content":"2023-03-13T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T09:24:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"ShaderMaterial(着色器材质)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-13T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-11T09:24:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"罗天旭\\",\\"url\\":\\"https://luotianxu1.github.io\\",\\"email\\":\\"1265062404@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"ShaderMaterial","slug":"shadermaterial","link":"#shadermaterial","children":[]},{"level":2,"title":"顶点着色器和片元着色器","slug":"顶点着色器和片元着色器","link":"#顶点着色器和片元着色器","children":[]},{"level":2,"title":"内置 attributes 和 uniforms","slug":"内置-attributes-和-uniforms","link":"#内置-attributes-和-uniforms","children":[]},{"level":2,"title":"自定义 attributes 和 uniforms","slug":"自定义-attributes-和-uniforms","link":"#自定义-attributes-和-uniforms","children":[]},{"level":2,"title":"构造器","slug":"构造器","link":"#构造器","children":[{"level":3,"title":"parameters : Object","slug":"parameters-object","link":"#parameters-object","children":[]}]},{"level":2,"title":"属性","slug":"属性","link":"#属性","children":[{"level":3,"title":".clipping : Boolean","slug":"clipping-boolean","link":"#clipping-boolean","children":[]},{"level":3,"title":".defaultAttributeValues : Object","slug":"defaultattributevalues-object","link":"#defaultattributevalues-object","children":[]},{"level":3,"title":".defines : Object","slug":"defines-object","link":"#defines-object","children":[]},{"level":3,"title":".extensions : Object","slug":"extensions-object","link":"#extensions-object","children":[]},{"level":3,"title":".fog : Boolean","slug":"fog-boolean","link":"#fog-boolean","children":[]},{"level":3,"title":".fragmentShader : String","slug":"fragmentshader-string","link":"#fragmentshader-string","children":[]},{"level":3,"title":".glslVersion : String","slug":"glslversion-string","link":"#glslversion-string","children":[]},{"level":3,"title":".index0AttributeName : String","slug":"index0attributename-string","link":"#index0attributename-string","children":[]},{"level":3,"title":".isShaderMaterial : Boolean","slug":"isshadermaterial-boolean","link":"#isshadermaterial-boolean","children":[]},{"level":3,"title":".lights : Boolean","slug":"lights-boolean","link":"#lights-boolean","children":[]},{"level":3,"title":".linewidth : Float","slug":"linewidth-float","link":"#linewidth-float","children":[]},{"level":3,"title":".flatShading : Boolean","slug":"flatshading-boolean","link":"#flatshading-boolean","children":[]},{"level":3,"title":".uniforms : Object","slug":"uniforms-object","link":"#uniforms-object","children":[]},{"level":3,"title":".uniformsNeedUpdate : Boolean","slug":"uniformsneedupdate-boolean","link":"#uniformsneedupdate-boolean","children":[]},{"level":3,"title":".vertexColors : Boolean","slug":"vertexcolors-boolean","link":"#vertexcolors-boolean","children":[]},{"level":3,"title":".vertexShader : String","slug":"vertexshader-string","link":"#vertexshader-string","children":[]},{"level":3,"title":".wireframe : Boolean","slug":"wireframe-boolean","link":"#wireframe-boolean","children":[]},{"level":3,"title":".wireframeLinewidth : Float","slug":"wireframelinewidth-float","link":"#wireframelinewidth-float","children":[]}]},{"level":2,"title":"方法","slug":"方法","link":"#方法","children":[{"level":3,"title":".clone () : ShaderMaterial this : ShaderMaterial","slug":"clone-shadermaterial-this-shadermaterial","link":"#clone-shadermaterial-this-shadermaterial","children":[]}]}],"git":{"createdTime":1726046677000,"updatedTime":1726046677000,"contributors":[{"name":"罗天旭","email":"1265062404@qq.com","commits":1}]},"readingTime":{"minutes":7.02,"words":2106},"filePathRelative":"threejs/材质/着色器材质.md","localizedDate":"2023年3月13日","excerpt":"<h2>ShaderMaterial</h2>\\n<p>使用自定义 shader 渲染的材质。 shader 是一个用 GLSL 编写的小程序 ，在 GPU 上运行。 您可能需要使用自定义 shader，如果你要：</p>\\n<ul>\\n<li>要实现内置 materials 之外的效果。</li>\\n<li>将许多对象组合成单个 BufferGeometry 以提高性能。</li>\\n</ul>\\n<p>使用 ShaderMaterial 时需要注意以下注意事项：</p>\\n<ul>\\n<li>ShaderMaterial 只有使用 WebGLRenderer 才可以绘制正常， 因为 vertexShader 和 fragmentShader 属性中 GLSL 代码必须使用 WebGL 来编译并运行在 GPU 中。</li>\\n<li>从 THREE r72 开始，不再支持在 ShaderMaterial 中直接分配属性。 必须使用 BufferGeometry 实例，使用 BufferAttribute 实例来定义自定义属性。</li>\\n<li>从 THREE r77 开始，WebGLRenderTarget 或 WebGLCubeRenderTarget 实例不再被用作 uniforms。 必须使用它们的 texture 属性。</li>\\n<li>内置 attributes 和 uniforms 与代码一起传递到 shaders。 如果您不希望 WebGLProgram 向 shader 代码添加任何内容，则可以使用 RawShaderMaterial 而不是此类。</li>\\n<li>您可以使用指令#pragma unroll_loop_start，#pragma unroll_loop_end 以便通过 shader 预处理器在 GLSL 中展开 for 循环。 该指令必须放在循环的正上方。循环格式必须与定义的标准相对应。\\n<ul>\\n<li>循环必须标准化 normalized。</li>\\n<li>循环变量必须是 i。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{p as comp,o as data};
