import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as e,b as a}from"./app-BrAc6PLC.js";const l="/img/study/html/reflow.jpg",n={};function h(p,i){return t(),e("div",null,i[0]||(i[0]=[a('<h2 id="重绘与回流" tabindex="-1"><a class="header-anchor" href="#重绘与回流"><span>重绘与回流</span></a></h2><ul><li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。</li><li>重排：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是重排</li></ul><p>我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复重排+重绘或者只有重绘。 重排必定会发生重绘，重绘不一定会引发重排。重绘和重排会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。重排所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p><h2 id="常见引起重排属性和方法" tabindex="-1"><a class="header-anchor" href="#常见引起重排属性和方法"><span>常见引起重排属性和方法</span></a></h2><p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，</p><ul><li>添加或者删除可见的DOM元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在input框中输入文字</li><li>浏览器窗口尺寸改变——resize事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li></ul><h2 id="常见引起重绘属性和方法" tabindex="-1"><a class="header-anchor" href="#常见引起重绘属性和方法"><span>常见引起重绘属性和方法</span></a></h2><figure><img src="'+l+`" alt=" " tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="如何减少重排、重绘" tabindex="-1"><a class="header-anchor" href="#如何减少重排、重绘"><span>如何减少重排、重绘</span></a></h2><ul><li>使用 transform 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量。</li></ul><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">for</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">++</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-dark:#7F848E;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">    // 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">document</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">querySelector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;.test&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">offsetTop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li><li>CSS 选择符从右往左匹配查找，避免节点层级过多</li><li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。</li></ul>`,12)]))}const d=s(n,[["render",h],["__file","重绘与重排.html.vue"]]),k=JSON.parse('{"path":"/study/HTML/%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92.html","title":"重绘与重排","lang":"zh-CN","frontmatter":{"title":"重绘与重排","icon":"html","order":3,"date":"2023-02-27T00:00:00.000Z","category":["HTML"],"tag":["页面渲染"],"description":"重绘与回流 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。 重排：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和...","head":[["meta",{"property":"og:url","content":"https://luotianxu1.github.io/study/HTML/%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92.html"}],["meta",{"property":"og:title","content":"重绘与重排"}],["meta",{"property":"og:description","content":"重绘与回流 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。 重排：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://luotianxu1.github.io/img/study/html/reflow.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-11T09:24:37.000Z"}],["meta",{"property":"article:author","content":"罗天旭"}],["meta",{"property":"article:tag","content":"页面渲染"}],["meta",{"property":"article:published_time","content":"2023-02-27T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-11T09:24:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"重绘与重排\\",\\"image\\":[\\"https://luotianxu1.github.io/img/study/html/reflow.jpg\\"],\\"datePublished\\":\\"2023-02-27T00:00:00.000Z\\",\\"dateModified\\":\\"2024-09-11T09:24:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"罗天旭\\",\\"url\\":\\"https://luotianxu1.github.io\\",\\"email\\":\\"1265062404@qq.com\\"}]}"]]},"headers":[{"level":2,"title":"重绘与回流","slug":"重绘与回流","link":"#重绘与回流","children":[]},{"level":2,"title":"常见引起重排属性和方法","slug":"常见引起重排属性和方法","link":"#常见引起重排属性和方法","children":[]},{"level":2,"title":"常见引起重绘属性和方法","slug":"常见引起重绘属性和方法","link":"#常见引起重绘属性和方法","children":[]},{"level":2,"title":"如何减少重排、重绘","slug":"如何减少重排、重绘","link":"#如何减少重排、重绘","children":[]}],"git":{"createdTime":1726046677000,"updatedTime":1726046677000,"contributors":[{"name":"罗天旭","email":"1265062404@qq.com","commits":1}]},"readingTime":{"minutes":2.36,"words":707},"filePathRelative":"study/HTML/重绘与重排.md","localizedDate":"2023年2月27日","excerpt":"<h2>重绘与回流</h2>\\n<ul>\\n<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。</li>\\n<li>重排：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是重排</li>\\n</ul>\\n<p>我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复重排+重绘或者只有重绘。\\n重排必定会发生重绘，重绘不一定会引发重排。重绘和重排会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。重排所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</p>","autoDesc":true}');export{d as comp,k as data};
