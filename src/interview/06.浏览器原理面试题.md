---
title: 浏览器原理面试题
icon: markdown
order: 6
date: 2023-02-17
category:
    - 面试
tag:
    - 浏览器原理
---
## 一、浏览器安全

### 1.什么是XSS攻击？

XSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如cookie等。

XSS的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。

攻击者可以通过这种攻击方式可进行以下操作：

- 获取页面的数据，如DOM、cookie、localStorage
- DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器
- 破坏页面结构
- 流量劫持（将链接指向某网站）

### 2.XSS攻击类型

XSS可以分为存储型、反射型和DOM型：

- 存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。
- 反射型指的是攻击者诱导用户访问一个带有恶意代码的URL后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有XSS代码的数据后当做脚本执行，最终完成XSS攻击。
- DOM型指的通过修改页面的DOM节点形成的XSS。

### 3.XSS攻击的步骤

#### 存储型XSS的攻击步骤

- 攻击者将恶意代码提交到目标网站的数据库中。
- 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在HTL中返回给浏览器。
- 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

#### 反射型XSS的攻击步骤

- 攻击者构造出特殊的URL,其中包含恶意代码。
- 用户打开带有恶意代码的URL时，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器。
- 用户刘览器接收到响应后解析执行，混在其中的恶意代码也被执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型XSS跟存储型XSS的区别是：存储型XSS的恶意代码存在数据库里，反射型XSS的恶意代码存在URL里。

反射型XSS漏洞常见于通过URL传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。

#### DOM型XSS的攻击步骤

- 攻击者构造出特殊的URL,其中包含恶意代码。
- 用户打开带有恶意代码的UL。
- 用户刘览器接收到响应后解析执行，前端JavaScript取出URL中的恶意代码并执行。
- 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM型XSS跟前两种XSS的区别：DOM型XSS攻击中，取出和执行恶意代码由浏览器端完成，属于前端JavaScript自身的安全漏洞，而其他两种XSS都属于服务端的安全漏洞。

### 4.如何防御XSS攻击？

可以看到XSS危害如此之大，那么在开发网站时就要做好防御措施，具体措施如下：

- 可以从浏览器的执行来进行予预防，一种是使用纯前端的方式，不用服务器端拼接后返▣（不使用服务端渲染）。另一种是对需要插入到HTML中的代码做好充分的转义。对于DOM型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取宿染和字符串拼接的时候应对可能出现的恶意代码情况进行判断。
- 使用CSP，CSP的本质是建立一个白名单，告浏览器哪些外部资源可以加载和执行，从而防上恶意代码的注入攻击。
  - CSP指的是内容安全策略，它的本质是建立一个白名单，告浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截油浏览器自己来实现。
  - 通常有两种方式来开启CSP,一种是设置HTTP首部中的Content--Security-Policy,一种是设置meta标签的方式
- 对一些敏感信息进行保护，比如cookie使用htp-only,使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。

### 5.什么是CSRF攻击？

CSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF攻击的本质是利用cook©会在同源清求中携带发送给服务器的特点，以此来实现用户的冒充。

### 6.CSRF攻击攻击类型

常见的CSRF攻击有三种：

- GET类型的CSRF攻击，比如在网站中的一个ig标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。
- POST类型的CSRF攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。
- 链接类型的CSRF攻击，比如在a标签的hrf属性里构建一个请求，然后诱导用户去点击。

### 7.如何防御CSRF攻击？

CSRF攻击可以使用以下方法来防护：

- 进行同源检测，服务器根据htp请求头中origin或者referer信息来判断请求是否为允许问的站点，从而对请求进行过滤。当origin或者referer信息都不存在的时候，直接阻l止请求。这种方式的缺点是有些情况下referer可以被伪造，同时还会把搜索引的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。(Referer字段会告诉服务器该网页是从哪个页面链接过来的)
- 使用CSRF Token进行验证，服务器向用户返回一个随机数Tokn,当网站再次发起请求时，在请求参数中加入服务器端返回的tokn,然后服务器对这个token进行验证。这种方法解决了使用cook单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个tokn,操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的session中没有保留这个token的话，就没有办法验证了。这种情况可以通过改变token的构建方式来解决。
- 对Cookie进行双重验证，服务器在用户访问网站页面时，向请求域名注入一个Cookie,内容为随机字符串，然后当用户再次向服务器发送请求的时候，从cookie中取出这个字符串，添加到URL参数中，然后服务器通过对cook中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用cookie,但是不能访问获取cookie的特点。并且这种方法比CSRF Token的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在XSS漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。
- 在设置cookie属性的时候设置Samesite,限制cookie不能作为被第三方使用，从而可以避免被攻击者利用。Samesite一共有两种模式，一种是严格模式，在严格模式下cookie在任何情况下都不可能作为第三方Cookie使用，在宽松模式下，cookie可以被请求是GET请求，且会发生页面跳转的请求所使用。

### 8.什么是中间人攻击？

中间人(Man-in-the-middle attack,MlTM)是指攻击者与通讯的两瑞分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被收击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。

### 9.中间人攻击过程

- 客户端发送请求到服务端，请求被中间人截获
- 服务器向客户端发送公钥
- 中间人截获公钥，保留在自己手上。然后自己生成一个伪造的公钥，发给客户端
- 客户端收到伪造的公钥后，生成动加密hash值发给服务器
- 中间人获得加密hash值，用自己的私钥解密获得真秘钥，同时生成假的加密hash值，发给服务器
- 服务器用私钥解密获得假密钥，然后加密数据传输给客户端

### 10.有哪些可能引起前端安全的问题？

- 跨站脚本(Cross-Site Scripting,XSS):一种代码注入方式，为了与CSS区分所以被称作XSS。早期常见于网络论坛，起因是网站没有对用户的输入进行严格的限制，使得攻击者可以将脚本上传到帖子让其他人浏览到有恶意脚本的页面，其注入方式很简单包括但不限于JavaScript/CSS/Flash等；
- iframe的滥用：iframe中的内容是由第三方来提供的，默认情况下他们不受控制，他们可以在iframe中运行JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端用户体验；
- 跨站点请求伪造(Cross-Site Request Forgeries,CSRF):指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击
- 恶意第三方库：无论是后端服务器应用还是前端应用开发，绝大多数时候都是在借助开发框架和各种类库进行快速开发，一旦第三方库被植入恶意代码很容易引起安全问题。

### 11.网络劫持有哪几种，如何防范？

- (1)DNS劫持：（输入京东被强制跳转到淘宝这就属于ds劫持）
  - DNS强制解析：通过修改运营商的本地DNS记录，来引导用户流量到缓存服务器
  - 302跳转的方式：通过监控网络出口的流量，分析判断哪些内容是可以进行劫持处理的，再对劫持的内存发起302跳转的回复，引导用户获取内容
- (2)HTTP劫特：（访问合歌但是一直有贪玩蓝月的广告），由于http明文传输，运营商会修改你的http响应内容（即加广告）

DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，而http劫特依然非常盛行，最有效的功法就是全站HTTPS,将HTTP加密，这使得运营商无法获取明文，就无法劫持你的响应内容。

## 二、进程与线程

### 1.进程与线程的概念

从本质上说，进程和线程都是CPU工作时间片的一个描述：

- 进程描述了CPU在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。
- 线程是进程中的更小单位，描述了执行一段指令所需的时间。

进程是资源分配的最小单位，线程是CPU调度的最小单位。

一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件：从处理器角度看，虚拟内存即虚拟地址空间。

如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。

进程和线程之间的关系有以下四个特点：

- 进程中的任意一线程执行出措，都会导致整个进程的崩溃。
- 线程之间共享进程中的数据。
- 当一个进程关闭之后，操作系统会回收进程所占用的内存，当一个进程退出时，操作系统会回收该进程所申请的所有资源：即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。
- 进程之间的内容相互隔离。进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程A写入数据到进程B的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。

![ ](/img/interview/chrome.jpg)

从图中可以看出，最新的Chrome浏览器包括：

- 1个浏览器主进程
- 1个GPU进程
- 1个网络进程
- 多个渲染进程
- 多个插件进程

这些进程的功能：

- 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- 渲染进程：核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，Chrome会为每个Tab标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- cPU进程：其实，GPU的使用初衷是为了实现3DCSS的效果，只是随后网页、Chrome的UI界面都选择采用GPU来绘制，这使得GPU成为刘览器普扁的需求。最后，Chrome在其多进程架构上也引入了GPU进程。
- 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

所以，打开一个网页，最少需要四个进程：1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程。如果打开的页面有运行插件的话，还需要再加上1个插件进程。

虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

- 更高的资源占用：因为每个进程都会包，含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。
- 更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

### 2.进程和线程的区别

- 进程可以看做独立应用，线程不能
- 资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。
- 通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助进程间通信。
- 调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I/O等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程CPU环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。

### 3.浏览器渲染进程的线程有哪些

浏览器的渲染进程的线程总共有五种：

- (1)GU渲染线程

负责渲染浏览器页面，解析HTML、CSS,构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要重绘或油于某种操作引发回流时，该线程就会执行。

注意：GU渲染线程和JS引擎线程是互斥的，当JS引擎执行时GU线程会被挂起，GU更新会被保存在一个队列中等到S引擎空闲时立即被执行。

- (2)Js引擎线程

JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；

注意：GU渲染线程与JS引擎线程的互关系，所以如果JS执行的时间过长，会造成预面的渲染不连贯，导致页面渲染加载阻塞。

- (3)时间触发线程

时间触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自刘览器内核的其他线程，如标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；

注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排邦队等待S引擎处理（当JS螫空闲时才会去执行）；

- (4)定时器触发进程

定时器触发进程即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待S引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件邦队列中：

注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms,如果是小于4ms,则默认为4ms。

- (5)异步http请求线程

  - XMLHttpRequesti连接后通过浏览器新开一个线程请求；
  - 检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；

### 4.进程之前的通信方式

#### (1)管道通信

管道是一种最基本的进程间通信机制。管道就是操作系统在内核中开辟的一段缓冲区，进程1可以
将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。

管道的特点：

- 只能单向通信
- 只能血缘关系的进程进行通信
- 依赖于文件系统
- 生命周期随进程
- 面向字节流的服务
- 管道内部提供了同步机制

#### (2)消息队列通信

消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。

使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。

#### (3)信号量通信

共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是1，然后a进程来访问内存1的时候，我们就把信号量的值设为0，然后进程b也要来访问内存1的时候，看到信号量的值为0就知道已经有进程在访问内存1了，这个时候进程b就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。

#### (4)信号通信

信号(Signals)是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。

#### (5)共享内存通信

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的PC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。

#### (6)套接字通信

上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候Socket这家伙就派上用场了，例如我们平时通过浏览器发起一个htp请求，然后服务器给你返回对应的数据，这种就是采用Socket的通信方式了。

### 5.僵尸进程和孤儿进程是什么？

- 孤儿进程：进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被iit进程（进程号为）所收养，并由iit进程对它们完成状态收集工作。
- 僵尸进程：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。

### 6.死锁产生的原因？

所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵特状态时，若无外力作用，它们都将无法再向前推进。

系统中的资源可以分为两类：

- 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统碌剥夺，CPU和主存均属于可剥夺性资源。
- 不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

### 7.产生死锁的原因？

- (1)竞争资源

  - 产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
  - 产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
- (2)进程间推进顺序非法

若P1保持了资源R1,P2保持了资源R2,系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1:Request(R2)时，将因R2已被P2占用而阻塞；当P2运行到P2:Request(R1)时，也将因R1已被P1占用而阻塞，于是发生进程死锁

### 8.产生死锁的必要条件？

- 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
- 请求和保特条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源在未使用完之前，不能寿剥夺，只能在使用完时由自己释放。
- 环路等待条件：在发生死锁时，必然存在一个进程一资源的环形链。

### 9.预防死锁的方法

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏清求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序清求资源，释放则相反（破坏环路等待条件）

### 10.如何实现浏览器内多个标签页之间的通信？

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后上这个中介者来进行消息的转发。通信方法如下：

- 使用websocket协议，因为websocket协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
- 使用ShareWorker的方式，shareWorker会在页面存在的生命周期内创建一个唯一的线程并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
- 使用localStorage的方式，我们可以在一个标签页对localStorage的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候localStorage对象就是充当的中介者的角色。
- 使用postMessage方法，如果我们能够获得对应标签页的引用，就可以使用postMessage方法，进行通信。

## 三、浏览器缓存

### 1.浏览器缓存的全过程

- 浏览器第一次加载资源，服务器返回200，浏览器从服务器下载资源文件，并缓存资源文件与response header,以供下次载时对比使用；
- 下一次载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回200时的时间差，如果没有超过cache-control设置的max-age,则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1,则使用expires头判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有If-Noe-Match和If-Modified-Since的请求；
- 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200：
- 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200；

![ ](/img/interview/cache.jpg)

很多网站的资源后面都加了版本号，这样做的目的是：每次升级了JS或CSS文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的JS或CSS文件，以保证用户能够及时获得网站的最新更新。

### 2.资源缓存的位置一共有3种，按优先级从高到低分别是

- Service Worker:Service Worker运行在JavaScript主线程之外，虽然由于脱离了浏览器窗体无法直接访问DOM,但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。当ServiceWorker没有命中缓存的时候，需要去调用fetch函数获取数据。也就是说，如果没有在Service Worker命中缓存，会根据缓存查找优先级去查找数据。但是不管是从Memory Cache中还是从网络请求中获取的数据，浏览器都会显示是从Service Worker中获取的内容。
- Memory Cache:Memory Cache就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭Tb页面，内存中的缓存也就被释放了。
- Disk Cache:Disk Cache也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之Memory Cache胜在容量和存储时效性上。在所有浏览器缓存中，Disk Cache覆盖面基本是最大的。它会根据HTTP Herder中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去清求数据。
- Push Cache:Push Cache是HTTP2中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话(Session)中存在，一旦会话结束就被释放。其具有以下特点：
  - 所有的资源都能被推送，但是Edge和Safari浏览器兼容性不怎么好
  - 可以推送no-cache和no-store的资源
  - 一旦连接被关闭，Push Cache就被释放
  - 多个页面可以使用相同的HTTP2连接，也就是说能使用同样的缓存
  - Push Cache中的缓存只能被使用一次
  - 浏览器可以拒绝接受已经存在的资源推送
  - 可以给其他域名推送资源

### 3.协商缓存和强缓存的区别

#### 强缓存

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。

强缓存策略可以通过两种方式来设置，分别是http头信息中的Expires属性和Cache-Control属性。

服务器通过在响应头中添加Eprs属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会彯响缓存命中的结果。

Expires是http1.0中的方式，因为它的一些缺点，在HTTP1.1中提出了一个新的头部属性就是Cache-Control属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，

Cache-Controli可设置的字段：

- public:设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用maX-age=来精确控制；
- private:设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的TML,通常都要设置这个字段值，避免代理服务器(CDN)缓存：
- no-cache:设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- no-stor:设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
- maX-age=:设置缓存的最大有效期，单位为秒；
- s-maxage:=:优先级高于maX-age=,仅适用于共享缓存(CDN),优先级高于maX-age或者Expires头；
- max-stale[=]:设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。

一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cche-Control的优先级要高于Expires。

no-cache和no-store很容易混淆：

- no-cache是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；
- no-store是指不使用任何缓存，每次请求都直接从服务器获取资源。

#### 协商缓存

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。上面已经说到了，命中协商缓存的条件有两个：

- maX-age=Xxx过期了
- 值为no-store

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个304状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是http头信息中的Etag和Last-Modified属性。

协商缓存也可以通过两种方式来设置，分别是http头信息中的Etag和Last-Modified属性。

(1)服务器通过在响应头中添加Last-Modified属性来指出资源最后一次修改的时间，当浏览器下一次发起清求时，会在清求头中添加一个If-Modified-Since的属性，属性值为上一次资源返回时的Last-Modified的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回304状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是Last-Modified标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是Last-Modified却没有改变，这样会造成缓存命中的不准确。

(2)因为Last-Modified的这种可能发生的不准确性，http中提供了另外一种方式，那就是Etag属性。服务器在返回资源的时候，在头信息中添加了Etag属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个lf-None-Match属性，这个属性的值就是上次返▣的资源的Etag的值。服务接收到请求后会根据这个值来和资源当前的Etg的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比Last-Modified的方式更加精确。

当Last-Modified和Etag属性同时出现的时候，Etag的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的Last-Modified应该保持一致，因为每个服务器上Etag的值都不一样，因此在考虑负载平衡时，最好不要设置Etag属性。

#### 总结

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。览器首先会根据请求的信息判断，强缓存是否命中，如果命中测直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。

### 4.为什么需要浏览器缓存？

对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。

所谓的浏览器缓存指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。

使用浏览器缓存，有以下优点：

- 减少了服务器的负担，提高了网站的性能
- 加快了客户端网页的加载度
- 减少了多余网络数据传输

### 5.点击刷新按钮或者按F5、按Ctrl+F5(强制刷新)、地址栏回车有什么区别？

- 点击刷新按钮或者按F5:浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since,if-None-Match,这就意味着服务器会对文件检查新渔鲜度，返回结果可能是304，也有可能是200.
- 用户按ctrl+F5(强制刷新)：浏览器不仅会对本地文件过期，而且不会带上If-Modifed-Since,If-None-Match,相当于之前从来没有请求过，返回结果是200。
- 地址栏回车：浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。

## 四、浏览器组成

### 1.常见的浏览器内核比较

- Trident:这种浏览器内核是IE浏览器用的内核，因为在早期IE占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于E的高市场占有率，微软也很长时间没有更新
- Trident内核，就导致了Trident内核和W3C标准脱节。还有就是Trident内核的大量Bug等安全问题没有得到解决，加上一些专家学者公开自己认为E浏览器不安全的观点，使很多用户开始转向其他浏览器。
- Gecko:这是Firefox和Flock所采用的内核，这个内核的优点就是功能强大、丰富，可以支特很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。
- Presto:Opera曾经采用的就是Presto内核，Presto内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理JS脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了部分网页兼容性。
- Vebkit:Vebkit是Safari采用的内核，它的优点就是网页浏览速度较快，虽然不及Presto但是也胜于Gecko和Trident,缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。VebKit前身是KDE小组的KHTML引擎，可以说VebKit是KHTML的一个开源的分支。
- Blink:谷歌在Chromium Blog上发表博客，称将与苹果的开源浏览器核心Nebkit分道扬镳，在Chromium项目中研发Blink渲染引擎（即浏览器核心），内置于Chrome浏览器之中。其实Blink引擎就是Vebkit的一个分支，就像webkit是KHTML的分支一样。Blink引擎现在是谷歌公司与Opera Software共同研发，上面提到过的，Opera弃用了自己的Presto内核，加入Google阵营，跟随谷歌一起研发Blink。

### 4.常见浏览器所用内核

(1)IE浏览器内核：Trident内核，也是俗称的E内核；
(2)Chrome刘览器内核：统称为Chromium内核或Chrome内核，以前是Vebkit内核，现在是Blink内核；
(3)Firefox浏览器内核：Gecko内核，俗称Firefox内核；
(4)Safari浏览器内核：ebkit内核，
(5)Opera浏览器内核：最初是自己的Presto内核，后来加入谷歌大军，从Vebkit又到了Blink内核；
(6)360浏览器、猎豹浏览器内核：IE+Chrome双内核：
(7)搜狗、遨游、QQ浏览器内核：Trident(兼容模式)+Webkit(高速模式)；
(8)百度浏览器、世界之窗内核：E内核；
(9)2345浏览器内核：好像以前是IE内核，现在也是E+Chrome双内核了；
(10)UC浏览器内核：这个众口不一，UC说是他们自己研发的U3内核，但好像还是基于Webkit和Trident,还有说是基于火孤内核。

## 五、浏览器渲染原理

### 1.浏览器的渲染过程

浏览器渲染主要有以下步骤：

- 首先解析收到的文档，根据文档定义构建一棵DOM树，DOM树是由DOM元素及属性节点组成的。
- 然后对CSS进行解析，生成CSSOM规则树。
- 根据DOM树和CSSOM规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和DOM元素相对应，但这种对应关系不是一对一的，不可见的DOM元素不会被插入渲染树。还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
- 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
- 布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的pait方法将它们的内容显示在屏幕上，绘制使用U川基础组件。

注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示部分内容，同时，可能还在通过网络下载其余内容。

### 2.渲染过程中遇到JS文件如何处理？

JavaScript的加载、解析与执行会阻塞文档的解析，也就是说，在构建DOM时，HTL解析器若遇到了JavaScript,那么它会暂停文档的解析，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应孩在首屏就载JS文件，这也是都建议将scpt标签放在body标签底部的原因。当然在当下，并不是说script标签必须放在底部，因为你可以给script标签添加defer或者async属性。

### 3.什么是文档的预解析？

Webkit和Firefox都做了这个优化，当执行JavaScript脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变DOM树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。

### 4.CSS如何阻塞文档解析？

理论上，既然样式表不改变DOM树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成CSSOM的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟JavaScript脚本执行和文档的解析，直至其完成CSSOM的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建CSSOM,然后再执行JavaScript,最后再继续文档的解析。

### 5.什么情况会阻塞渲染？

首先渲染的前提是生成渲染树，所以HTL和CSS肯定会阻塞渲染。如果你想渲染的越快，你越应该郊降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到script标签时，会暂停构建DOM,完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载JS文件，这也是都建议将script标签放在body标签底部的原因。

当然在当下，并不是说script标签必须放在底部，因为你可以给script标签添加defer或者async属性。当script标签加上defer属性以后，表示该JS文件会并行下载，但是会放到HTML解析完成后顺序执行，所以对于这种情况你可以把sct标签放在任意位置。对于没有任何依赖的JS文件可以加上async属性，表示JS文件下载和解析不会阻塞渲染。
