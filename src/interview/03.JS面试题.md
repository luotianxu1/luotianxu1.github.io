---
title: JS面试题
icon: markdown
order: 3
date: 2023-02-17
category:
    - 面试
tag:
    - Javascript
---

## 一、数据类型

### 1.null 和 undefined 区别

首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。

undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。

undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。

### 2.typeof null 的结果是什么，为什么？

typeof null 的结果是 Object。

在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：

```text
000: object   - 当前存储的数据指向一个对象。
  1: int      - 当前存储的数据是一个 31 位的有符号整数。
010: double   - 当前存储的数据指向一个双精度的浮点数。
100: string   - 当前存储的数据指向一个字符串。
110: boolean  - 当前存储的数据是布尔值。
```

如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。

有两种特殊数据类型：

- undefined 的值是 (-2)30(一个超出整数范围的数字)；
- null 的值是机器码 NULL 指针(null 指针的值全是 0)

那也就是说 null 的类型标签也是 000，和 Object 的类型标签一样，所以会被判定为 Object。

### 3.typeof NaN 的结果是什么？

NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

```js
typeof NaN // "number"
```

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。

### 4.intanceof 操作符的实现原理及实现

instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left)
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype; 

  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    proto = Object.getPrototypeOf(proto);
  }
}
```

### 5.isNaN 和 Number.isNaN 函数的区别？

- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。
- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

### 6.为什么 0.1+0.2！==0.3，如何让其相等

在开发过程中遇到类以这样的问题：

```js
let n1 = 0.1,
    n2 = 0.2
conso1e.log(n1 + n2) //0.30000000000000004
```

这里得到的不是想要的结果，要想等于 0.3，就要把它进行转化：

```js
;(n1 + n2).toFixed(2) //注意，toFixed为四舍五入
```

toFixed(num)方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？

计算机是通过二进制的方式存储数据的，所以计算机计算 0.1+0.2 的时候，实际上是计算的两个数的二进制的和。0.1 的二进制是 0.0001100110011001100...(1100 循环)，0.2 的二进制是：0.00110011001100...(1100 循环)，这两个数的二进制都是无限循环的数。那 JavaScript 是如何处理无限循环的二进制小数呢？

一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number,它的实现遵循 IEEE754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留 52 位，再加上前面的 1，其实就是保留 53 位有效数字，剩余的需要舍去，遵从“0 舍 1 入"的原则。

根据这个原则，0.1 和 0.2 的二进制数相加，再转化为十进制数就是：0.30000000000000004。

一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对 JavaScript 来说，这个值通常为 2-52，在 ES6 中，提供了 Number.EPSILON 属性，而它的值就是 2-52，只要判断 0.1+0.2-0.3 是否小于 Number..EPSILON,如果小于，就可以判断为 0.1+0.2===0.3

```js
function numberepsilon(argl,arg2){
    return Math.abs (argl arg2)<Number.EPSILON;
    console.log(numberepsilon(0.1 0.2,0.3));//true
}
```

### 7.JavaScript 有哪些数据类型，它们的区别？

JavaScript 共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。

其中 Symbol 和 BigInt 是 ES6 中新增的数据类型：

- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。
- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

这些数据可以分为原始数据类型和引用数据类型：

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String）
- 堆：引用数据类型（对象、数组和函数）

两种类型的区别在于存储位置的不同：

- 原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；
- 引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：

- 在数据结构中，栈中数据的存取方式为先进后出。
- 堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。

在操作系统中，内存被分为栈区和堆区：

- 栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
- 堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。

### 8.+ 操作符什么时候用于字符串的拼接？

根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。

简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

### 9.数据类型检测的方式有哪些

#### typeof

````js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object    
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object
````

其中数组、对象、null都会被判断为object，其他判断都正确。

#### instanceof

instanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。

```js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false 
console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
```

可以看到，instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

#### constructor

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
```

constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了：

```js
function Fn(){};
 
Fn.prototype = new Array();
 
var f = new Fn();
 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true
```

#### Object.prototype.toString.call()

```js
var a = Object.prototype.toString;
 
console.log(a.call(2));
console.log(a.call(true));
console.log(a.call('str'));
console.log(a.call([]));
console.log(a.call(function(){}));
console.log(a.call({}));
console.log(a.call(undefined));
console.log(a.call(null));
```

## 二、ES6

### 1.ES6 新特性

1. 新增块级作用域（let、const）
2. 新增定义类的语法糖（class）
3. 新增了一种基本数据类型（symbol）
4. 新增了结构赋值
5. 新增了函数参数的默认值
6. 新增数组 API
7. 对象和数组新增了扩展运算符
8. Promise
9. 新增模块化（import export）
10. 新增 set 和 map 数据结构
11. 新增 generator
12. 新增箭头函数

### 2.var、let、const

- var

1. 声明提升
2. 变量覆盖
3. 没有块作用域
4. 不存在暂时性死区

```js
// 声明提升
console.log(name) //ltx
var name = 'ltx'
```

```js
// 变量覆盖
var name = '123'
var name = '456'
console.log(name) // '456'
```

```js
// 没有块作用域
function fn2() {
    for (var i = 0; i < 5; i++) {}
    console.log(i) // 5
}
fn(2)
```

```js
var a = 0
consolg.log(a, window.a) // 0,0
if (true) {
    consolg.log(a, window.a) // fn,0
    a = 10
    consolg.log(a, window.a) // 10,0
    function a() {} // 提升 隐式操作
    consolg.log(a, window.a) // 10,10
    a = 20
    consolg.log(a, window.a) // 20,10
}
consolg.log(a, window.a) // 10,10
```

- const

1. const 声明之后必须赋值
2. const 定义的值不能修改
3. const 支持块级作用域不存在声明提升和变量覆盖
4. 存在暂时性死区

![ ](/img/interview/let.jpg)

### 3.const 对象的属性可以修改吗

const 保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const 只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

### 4.为什么要进行变量提升，它导致了什么问题？

变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。

造成变量声明提升的本质原因是 JS 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。

首先要知道，JS 在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。

- 在解析阶段，JS 会检查语法，并对函数进行予预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为 undefined,函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出 this、arguments7 和函数的参数。
  - 全局上下文：变量定义，函数声明
  - 函数上下文：变量定义，函数声明，this,arguments
- 在执行阶段，就是按照代码的顺序衣次执行。

那为什么会进行变量提升呢？主要有以下两个原因：

- 提高性能
    在 JS 代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。
    在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配浅空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。
- 容错性更好
    变量提升可以在一定程度上提高 JS 的容错性，看下面的代码：

```js
a = 1
var a
console.log(a)
```

如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就河以正常执行。虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。

### 5.暂时性死区

在代码块内，使用 let 命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）

```js
let a = 'a'
function log() {
    console.log(a)
    let a = 'b'
}
log() // ReferenceError: a is not defined
```

在本实例中，变量 a 的作用域，一个是全局作用域，另一个是函数作用域，已经被确定。也就是说函数内部的 a 此时已经确定为函数内部的作用域。

在执行阶段时，根据作用域链原则，函数内部会先寻找函数内部的作用域变量， 既然 a 在函数中已经被确定，那么就不会向全局作用域去寻找 a 了。默认函数内部 a 是已经定义的。但函数顺序执行的时候，访问 a 的同时并没有在访问之前声明 a，也就是树在当前作用域下，没有找到 a 的生命和定义，就会出现 为定义的错误了。

### 6.箭头函数与普通函数的区别

- 箭头函数处比普通函数更加简洁
  - 如果没有参数，就直接写一个空括号即可
  - 如果只有一个参数，可以省去参数的括号
  - 如果有多个参数，用逗号分割
  - 如果函数体的返回值只有一句，可以省略大括号
  - 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个 Void 关键字。最常见的就是调用一个函数：`let fn ()=void doesNotReturn()`
- 箭头函数没有自己的 this
    箭头函数不会创建自己的 this,所以它没有自己的 this,它只会在自己作用域的上一层继承 this。所以箭头函数中 ths 的指向在它在定义时已经确定了，之后不会改变。
- 箭头函数继承来的 this 指向永远不会改变

```js
var id ='GLOBAL';
var obj={
    id:'OBJ',
    a:function(){
        console.log(this.id);
    },
    b:0=>{
        console.log(this.id);
    }
};
obj.a();//'0BJ'
obj.b();//'GLOBAL'
new obj.a()//undefined
new obj.b()//Uncaught TypeError:obj.b is not a constructor
```

对象 obj 的方法 b 是使用箭头函数定义的，这个函数中的 ts 就永远指向它定义时所处的全局执行环境中的 this,即便这个函数是作为对象 obj 的方法调用，this 依旧指向 Window 对象。需要注意，定义对象的大括号引是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。

- call()、apply()、bind()等方法不能改变箭头函数中 this 的指向

```js
var id='Global';
let fun1 =()=>{
    console.log(this.id)
}
fun1()
//'G1oba1'
fn1.ca11({id:’0bj'})
//'G1oba1'
fun1.apply ({id:'Obj'})
//'Global'
fun1.bind({id:'Obj'})();//'Global
```

- 箭头函数不能作为构造函数使用构造函数在 new 的步骤在上面已经说过了，实际上第二步就是将函数中的 this 指向该对象。但是由于箭头函数时没有自己的 this 的，且 this 指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。
- 箭头函数没有自己的 arguments
    箭头函数没有自己的 arguments 对象。在箭头函数中问 arguments 实际上获得的是它外层函数的 arguments 值。
- 箭头函数没有 prototype
- 箭头函数不能用作 Generatori 函数，不能使用 veild 关键字

### 7.扩展运算符的作用及使用场景

#### (1)对象扩展运算符

对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。

```js
let bar = { a: 1, b: 2 }
let baz = { ...bar } //{a:1,b:2}
```

上述方法实际上等价于：

```js
let bar = { a: 1, b: 2 }
let baz = Object.assign({}, bar) //a:1,b:2
```

Object.assign 方法用于对象的合并，将源对象(source)的所有可枚举属性，复制到目标对象(target)。Object.assign 方法的第一个参数是日标对象，后面的参数都是源对象。（如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性）。

同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉

```js
let bar = {a:1,b:2}
let baz={..bar,..{a:2,b:4}}//{a:2,b:4}
```

利用上述特性就可以很方便的修改对象的部分属性。在 redux 中的 reduceri 函数规定必须是一个纯函数，reducer 中的 state 对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。

需要注意：扩展运算符对对象实例的拷贝属于浅拷贝

#### (2)数组扩展运算符

数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

```js
conso1e.log(...[1, 2, 3])
//123
conso1e.log(...[1, [2, 3, 4], 5])
//1[2,3,4]5
```

- 将数组转换为参数序列

```js
function add(x, y) {
    return x + y
}
const numbers = [1, 2]
add(...numbers) //3
```

- 复制数组

```js
const arr1 = [1,2]
const arr2 = [..arr1]
```

- 合并数组

```js
const arrl ['two','three']
const arr2 =['one',...arrl,'four','five']
//["one","two”,"three”,"four","five"]
```

- 扩展运算符与解构赋值结合起来，用于生成数组

```js
const [first, ...rest] = [1, 2, 3, 4, 5]
first //1
rest //[2,3,4,5]
```

需要注意：如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

```js
const [..rest,1ast]=[1,2,3,4,5]//报错
const [first,..rest,1ast]=[1,2,3,4,5]//报错
```

- 将字符串转为真正的数组

```js
;[...'he11o'] //["h","e","1","1”,"0”]
```

### 8.Proxy 可以实现什么功能？

在 Vue3.0 中通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。

Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。

```js
let p = new Proxy(target, handler)
```

target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。

下面来通过 Proxy 来实现一个数据响应式：

```js
let onWatch = (obj, setBind, getLogger) => {
    let handler = {
        get(target, property, receiver) {
            getLogger(target, property)
            return Reflect.get(target, property, receiver)
        },
        set(target, property, value, receiver) {
            setBind(value, property)
            return Reflect.set(target, property, value)
        },
    }
    return new Proxy(obj, handler)
}
let obj = { a: 1 }
let p = onWatch(
    obj,
    (v, property) => {
        console.log(`监听到属性${property}改变为${v}`)
    },
    (target, property) => {
        console.log(`'${property}' = ${target[property]}`)
    }
)
p.a = 2 // 监听到属性a改变
p.a // 'a' = 2
```

在上述代码中，通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。

当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。

### 9.对对象与数组的解构的理解

解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。

#### (1)数组的解构

在解构数组时，以元素的位置为匹配条件来提取想要的数据的：

```js
const [a, b, c] = [1, 2, 3]
```

最终，a、b、c 分别被赋予了数组第 0、1、2 个索引位的值

数组里的 0、1、2 索引位的元素值，精准地被映射到了左侧的第 0、1、2 个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：

```js
const [a, , c] = [1, 2, 3]
```

通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量

#### (2)对象的解构

对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：

```js
const stu = {
    name: 'Bob',
    age: 24,
}
```

假如想要解构它的两个自有属性，可以这样：

```js
const { name, age } = stu
```

这样就得到了 name 和 age 两个和 stu 平级的变量

注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：

```js
const { age, name } = stu
```

### 10.如何提取高度嵌套的对象里的指定属性？

```js
const school = {
    classes: {
        stu: {
            name: 'Bob',
            age: 24,
        },
    },
}

const {
    classes: {
        stu: { name },
    },
} = school
console.log(name)
```

### 11.对 rest 参数的理解

扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组：

```js
function mutiple(...args) {
    let result = 1
    for (var val of args) {
        result *= val
    }
    return result
}
mutiple(1, 2, 3, 4) // 24
```

这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：

```js
function mutiple(...args) {
    console.log(args)
}
mutiple(1, 2, 3, 4) // [1, 2, 3, 4]
```

### 12.ES6 中模板语法与字符串处理

ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：

```js
var name = 'css'
var career = 'coder'
var hobby = ['coding', 'writing']
var finalString =
    'my name is ' +
    name +
    ', I work as a ' +
    career +
    ', I love ' +
    hobby[0] +
    ' and ' +
    hobby[1]
```

仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：

```js
var name = 'css'
var career = 'coder'
var hobby = ['coding', 'writing']
var finalString = `my name is ${name}, I work as a ${career} I love ${hobby[0]} and ${hobby[1]}`
```

字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：

- 在模板字符串中，空格、缩进、换行都会被保留
- 模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算

基于第一点，可以在模板字符串里无障碍地直接写 html 代码：

```js
let list = `
    <ul>
        <li>列表项1</li>
        <li>列表项2</li>
    </ul>
`
console.log(message) // 正确输出，不存在报错
```

基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：

```js
function add(a, b) {
    const finalString = `${a} + ${b} = ${a + b}`
    console.log(finalString)
}
add(1, 2) // 输出 '1 + 2 = 3'
```

除了模板语法外， ES6 中还新增了一系列的字符串方法用于提升开发效率：

存在性判定：在过去，当判断一个字符/字符串是否在某字符串中时，只能用 indexOf > -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。

- includes：判断字符串与子串的包含关系：

```js
const son = 'haha'
const father = 'xixi haha hehe'
father.includes(son) // true
```

- startsWith：判断字符串是否以某个/某串字符开头：

```js
const father = 'xixi haha hehe'
father.startsWith('haha') // false
father.startsWith('xixi') // true
```

- endsWith：判断字符串是否以某个/某串字符结尾：

```js
const father = 'xixi haha hehe'
father.endsWith('hehe') // true
```

- 自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：

```js
const sourceCode = 'repeat for 3 times;'
const repeated = sourceCode.repeat(3)
console.log(repeated) // repeat for 3 times;repeat for 3 times;repeat for 3 times;
```

## 三、Javascript基础

### 1.JavaScript 由哪三部分组成

1. ECMAScript：JS 的核心内容，描述了语言的基础语法，比如 var，for
2. 文档对象模型（DOM）:它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口
3. 浏览器对象模型（BOM）:它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window,而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Gob!(全局)对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 I1 ocation 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象

### 2.JavaScript 由哪些内置对象

- 值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。
    例如 Infinity、NaN、undefined、null 字面量
- 函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。
    例如 eval()、parseFloat()、parselnt()等
- 基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。
    例如 Object、.Function、Boolean、.Symbol、.Error 等
- 数字和日期对象，用来表示数字、日期和执行数学计算的对象。
    例如 Number、Math、Date
- 字符串，用来表示和操作字符串的对象。
    例如 String、RegExp
- 可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。
    例如 Array
- 使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。
    例如 Map、Set、VeakMap、.WeakSet
- 矢量集合，SMD 矢量集合中的数据会被组织为一个数据序列。
    例如 SIMD 等
- 结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。
    例如 JSON 等
- 控制抽象对象
    例如 Promise、Generator 等
- 反射
    例如 Reflect、Proxy
- 国际化，为了支持多语言处理而加入 ECMAScript 的对象。
    例如 lntl、lnt.Collator 等
- WebAssembly
- 其他
    例如 arguments

js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined,全局函数如 parselnt0()、parseFloat()用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。

### 3.JavaScript 脚本延迟加载的方式有哪些？

延迟加载就是等页面加载完成之后再加载 JavaScript 文件。js 延迟加载有助于提高页面加载速度。

一般有以下几种方式：

- defer 属性：给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
- async 属性：给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 a$yc 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
- 动态创建 DOM 方式：动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
- 使用 setTimeout 延迟方法：设置一个定时器来延迟加载 js 脚本文件
- 让 Js 最后加载：将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

### 4.对 JSON 的里解

JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。

在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。

因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的.

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，

- JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。
- JSON.parse 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。

### 5.操作数组的方法

- push
- pop
- sort
- splice
- unshift
- shift
- reverse
- concat
- join
- map
- filter
- ervery
- some
- reduce
- isArray
- findIndex

> 哪些方法会改变原数组：push、pop、unshift、shift、sort、reverse、splice

- 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。
- 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。
- 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。
- 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。
- 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。
- 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法
- 数组归并方法 reduce() 和 reduceRight() 方法

### 6.为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组？

arguments 是一个对象，它的属性是从 0 开始依次递增的数字，还有 callee 和 length 等属性，与数组相似；但是它却没有数组常见的方法属性，如 forEach,reduce 等，所以叫它们类数组。

要扁历类数组，有三个方法：

- 将数组的方法应用到类数组上，这时候就可以使用 cal 和 apply 方法，如：

```js
function foo() {
    Array.prototype.forEach.call(arguments, (a = console.log(a)))
}
```

- 使用 Array.from 方法将类数组转化成数组：

```js
function foo() {
    const arrArgs = Array.from(arguments)
    arrArgs.forEach((a = console.log(a)))
}
```

- 使用展开运算符将类数组转化成数组

```js
function foo() {
    const arrArgs = [...arguments]
    arrArgs.forEach((a = console.log(a)))
}
```

### 7.new 操作具体做了什么

1. 首先创建了一个新的空对象`{}`
2. 设置原型，将对象的原型设置为函数的 prototype 对象`son.__proto__ = Father.prototype`
3. 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）`Father.call(this)`
4. 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

```js
function newFun(Fun, ...args) {
    // 创建一个新对象
    let newObj = {}
    // 把空对象和构造函数通过原型链进行连接
    newObj.__proto__ = Fun.prototype
    // 把构造函数的this绑定到新的空对象身上
    const result = Fun.apply(newObj, args)
    // 根据构建函数返回的类型判断，如果是值类型，则返回对象，如果是引用类型，就要返回这个引用类型
    return result instanceof Object ? result : newObj
}
function Person(name) {
    this.name = name
}
Person.prototype.say = function () {
    console.log('123')
}
const p1 = newFun(Person, '张三')
p1.say()
console.log(p1)
```

### 8.Map（字典）

Map 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者原始值）都可以作为一个键或一个值。

- Map 对象这种数据结构和和对象类型，都已键值对的形式存储数据，即 key-vlue 形式。
- Map 对象存储的数据是有序的，而我们平常使用的对象是无序的，所以通常当我们需要使用对象形式（键值对）存储数据且需要有序时，采用 Map 对象进行存储。
- Map 对象的键值可以是任意类型，我们平时使用的对象只能使用字符串作为键。

> 基本使用

```js
let defaultMap = new Map([
    ['name', '张三'],
    ['age', 20],
])
```

![ ](/img/interview/Map.jpg)

```js
myMap.set('name', '小猪课堂') // 字符串作为键
myMap.set(12, '会飞的猪') // number 类型作为键
myMap.set({}, '知乎') // 对象类型作为键
```

![ ](/img/interview/Map2.jpg)

> 获取长度

```js
let myMapSize = myMap.size
```

> 获取值

```js
let objKey = {}
myMap.set('name', '小猪课堂') // 字符串作为键
let name = myMap.get('name')
console.log(name) // 小猪课堂 会飞的猪 知乎
```

> 删除某个值

```js
myMap.delete('name')
```

> 判断某个值是否存在

```js
myMap.has('name') // 返回 bool 值
```

> 清楚所有成员

```js
myMap.clear()
```

> 返回键名的遍历器

```js
for (let key of map.keys()) {
    console.log(key)
}
```

> 返回键值的扁历器

```js
for (let value of map.values()) {
    console.log(value)
}
```

> 返回所有成员的遍历器

```js
for (let items of map.entries()) {
    console.log(items)
}
```

> 扁历 Map 的所有成员

```js
map.forEach((value, key, map) => {
    console.log(key, value)
})
```

### 9.Set（集合）

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。

- Set 对象是一个类数组对象，它长得就很像数组。
- Set 对象存储的值是不重复的，所以我们通常使用它来实现数组去重。
- Set 对象存储的数据不是键值对的形式，而且它可以存储任何类型的数据。

> 基本使用

```js
let defaultSet = new Set(['张三', 12, true])
```

![ ](/img/interview/Set.jpg)

> 插入数据

```js
mySet.add(1)
```

> 获取长度

```js
let mySetSize = mySet.size
```

> 获取值

由于 Set 对象存储的不是键值对形式，所以未提供 get 方法获取值，我们通常遍历它获取值：

```js
mySet.forEach((item) => {
    console.log(item)
})
```

> 删除某个值

```js
mySet.delete(1)
```

> 判断某个值是否存在

```js
mySet.has(1) // 返回Boolean值
```

### 10.Map 与 Set 的区别

- Map 和 Set 查找速度都非常快，时间复杂度为 O(1)，而数组查找的时间复杂度为 O(n)。
- Map 对象初始化的值为一个二维数组，Set 对象初始化的值为一维数组。
- Map 对象和 Set 对象都不允许键重复（可以将 Set 对象的键想象成值）。
- Map 对象的键是不能改的，但是值能改，Set 对象只能通过迭代器来更改值。

### 11.Map和Object的区别

| 生命周期      |          Map            |  Object   |
| :------------ | :-------------------------------------------------------------------: | :-------------------------: |
| 意外的键  |     Map默认情况不包含任何键，只包含显式插入的键。       |  Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。  |
| 键的类型       | Map的键可以是任意值，包括函数、对象或任意基本类型。 |  Object 的键必须是 String 或是Symbol。  |
| 键的顺序 |  Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。    |  Object 的键是无序的  |
| Size       |   Map 的键值对个数可以轻易地通过size 属性获取    |  Object 的键值对个数只能手动计算  |
| 迭代  |     Map 是 iterable 的，所以可以直接被迭代。     |  迭代Object需要以某种方式获取它的键然后才能迭代。  |
| 性能       |      在频繁增删键值对的场景下表现更好。           |  在频繁添加和删除键值对的场景下未作出优化。  |

### 11.防抖

- 事件被触发 n 秒后再执行回调，如果在这 n 秒内又被调用，则重新计时。 在一段时间内，事件只会最后触发一次。scroll 事件滚动、搜索框输入查询、表单验证、按钮提交、浏览器缩放

```js
function debounce(func, wait) {
    let timeout
    return function () {
        const that = this
        const args = arguments
        clearTimeout(timeout)
        timeout = setTimeout(function () {
            func.apply(that, args)
        }, wait)
    }
}

// 立即执行防抖
function debounce(func, wait, immediate) {
    let timeout
    return function () {
        const that = this
        const args = arguments
        clearTimeout(timeout)
        if (immediate) {
            const callNow = !timeout
            timeout = setTimeout(function () {
                timeout = null
            }, wait)
            if (callNow) {
                func.apply(that, args)
            }
        } else {
            timeout = setTimeout(function () {
                func.apply(that, args)
            }, wait)
        }
    }
}

// 取消防抖
function debounce(func, wait) {
    let timeout
    let debounced = function () {
        const that = this
        const args = arguments
        clearTimeout(timeout)
        timeout = setTimeout(function () {
            func.apply(that, args)
        }, wait)
    }
    debounced.cancel = function () {
        clearTimeout(timeout)
        timeout = null
    }
    return debounced
}
```

### 12.节流

- 在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。按照一段时间的间隔来进行触发。

```js
// 时间戳 立即执行
function throttle(func, awit) {
    let old = 0
    return function () {
        const that = this
        const args = arguments
        let now = newDate().valueOf()
        if (now - old > wait) {
            func.apply(that, func)
            old = now
        }
    }
}

// 使用定时器 第一次不执行，最后一次调用会执行
function throttle(func, wait) {
    let timeout
    return function () {
        const that = this
        const args = arguments
        if (!timeout) {
            timeout = setTimeout(function () {
                func.apply(that, args)
                timeout = null
            }, wait)
        }
    }
}
```

### 13.柯里化

把接收多个参数的函数，变成一个接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数，而且返回结果的新函数的技术。

- 为什么需要有函数柯里化？

1. 逻辑单一
2. 函数参数复用

```js
function foo(x, y, z) {
    console.log(x + y + z)
}
foo(10, 20, 30) // 60

function foo2(x) {
    return function (y) {
        return function (z) {
            console.log(x + y + z)
        }
    }
}
foo2(10)(20)(30) // 60

let foo3 = (x) => (y) => (z) => {
    console.log(x + y + z)
}
foo3(10)(20)(30) // 60
```

> 案例一

```js
// 信息一： 日志类型
// 信息二： 日志的类型：info/debug/feature
// 信息三： 具体信息
function logInfo(date, type, message) {
    console.log(`时间：${date} 类型：${type} 内容${message}`)
}
logInfo('2023-02-07', 'debug', '修复界面bug')
logInfo('2023-02-07', 'debug', '修复界面bug')
logInfo('2023-02-07', 'debug', '修复界面bug')

// 柯里化
let logInfo2 = (date) => (type) => (message) => {
    console.log(`时间：${date} 类型：${type} 内容${message}`)
}
let logToday = logInfo2('2023-02-08')
let logTodayDeBug = logToday('debug')
let logTodayFrature = logToday('feature')
logTodayDeBug('服务器') //时间：2023-02-08 类型：debug 内容服务器
logTodayFrature('按钮') //时间：2023-02-08 类型：feature 内容按钮
```

> 案例二

```js
function makeAdder(count) {
    function add(num) {
        return count + num
    }
    return add
}

let adder5 = makeAdder(5)
console.log(adder5(5))
console.log(adder5(10))
```

### 14.深拷贝与浅拷贝

```js
// 引用数据类型（数组，对象）
function deepClone(source) {
    // [] => Array(基类) {} => Object
    const targetObj = source.constructor === Array ? [] : {}
    for (let keys in source) {
        if (source.hasOwnProperty(keys)) {
            // keys => 3种
            if (source[keys] && typeof source[keys] === 'object') {
                targetObj[keys] = deepClone(source[keys])
            } else {
                // 基本数据类型，直接赋值
                targetObj[keys] = source[keys]
            }
        }
    }
    return targetObj
}

let obj = {
    ff: 'name',
    gg: 1,
    obj: { str: '111', age: 12 },
    arr: [1, 2, 3, 4],
}
let newObjC = deepClone(obj)
newObjC.ff = '123'
console.log(obj)
console.log(newObjC)
```

### 15.事件委托

利用事件冒泡的机制来实现，把子元素的事件绑定到了父元素身上，如果子元素阻止了事件冒泡，那么委托也就不成立。

阻止事件冒泡： event.stopPropagation()
addEventListener('click',函数名,true/false) 默认是 false(事件冒泡)true(事件捕获)

### 16.事件循环

> 任务队列

- JS 分为同步任务和异步任务
- 同步任务都在主线程上执行，形成一个执行栈
- 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
- 一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

> 宏任务

可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。浏览器为了能够使得 JS 内部(macro)task 与 DOM 任务能够有序的执行，会在一个(macro)task 执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染。

task 主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境)

> 微任务

可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。

microtask 主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境)

> 运行机制

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染
- 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取）

![ ](/img/interview/task.jpg)

> 面试题

- 面试题 1

```js
console.log('script start')
setTimeout(function () {
    console.log('setTimeout1')
    new Promise(function (resolve) {
        resolve()
    }).then(function () {
        new Promise(function (resolve) {
            resolve()
        }).then(function () {
            console.log('then4')
        })
        console.log('then2')
    })
})
new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('then1')
})
setTimeout(function () {
    console.log('setTimeout2')
})
console.log(2)
queueMicrotask(() => {
    console.log('queueMicrotask1')
})
new Promise(function (resolve) {
    resolve()
}).then(function () {
    console.log('then3')
})
console.log('script end')
// script start
// promise1
// 2
// script end

// then1
// queueMicrotask1
// then3

// setTimeout1
// then2
// then4

// setTimeout2
```

- 面试题 2

```js
console.log('script start')

function requestData(url) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log('setTimeout')
            resolve(url)
        }, 2000)
    })
}

function getData() {
    console.log('getData start')
    requestData('why').then((res) => {
        console.log('then1-res', res)
    })
    console.log('getData end')
}

getData()

console.log('script end')

// script start
// getData start
// getData end
// script end
// setTimeout
// then1-res why
```

- 面试题 3

```js
console.log('script start')

function requestData(url) {
    console.log('requestData')
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log('setTimeout')
            resolve(url)
        }, 2000)
    })
}

async function getData() {
    console.log('getData start')
    const res = await requestData('why')
    console.log('then1-res', res)
    console.log('getData end')
}

getData()

console.log('script end')

// script start
// getData start
// requestData
// script end
// setTimeout
// then1-res why
// getData end
```

- 面试题 4

```js
async function async1() {
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}

async function async2() {
    console.log('async2')
}

console.log('script start')

setTimeout(function () {
    console.log('setTimeout')
}, 0)

async1()

new Promise(function (resolve) {
    console.log('promise1')
    resolve()
}).then(function () {
    console.log('proimse2')
})

console.log('script end')

// script start
// async1 start
// async2
// promise1
// script end
// async1 end
// proimse2
// setTimeout
```

- 面试题 5

```js
console.log('start')
setTimeout(() => {
    console.log('setTimeout1')
}, 0)
;(async function foo() {
    console.log('async 1')
    await asyncFunction()
    console.log('async2')
})().then(console.log('foo.then'))
async function asyncFunction() {
    console.log('asyncFunction')
    setTimeout(() => {
        console.log('setTimeout2')
    }, 0)
    new Promise((res) => {
        console.log('promise1')
        res('promise2')
    }).then(console.log)
}
console.log('end')

// start
// async 1
// asyncFunction
// promise1
// foo.then
// end
// promise2
// async2
// setTimeout1
// setTimeout2
```

1. 最开始碰到 console.log("start"); 直接执行并打印出 start
2. 往下走，遇到一个 setTimeout1 就放到宏任务队列
3. 碰到立即执行函数 foo， 打印出 async 1
4. 遇到 await 堵塞队列，先 执行 await 的函数
5. 执行 asyncFunction 函数， 打印出 asyncFunction
6. 遇到第二个 setTimeout2， 放到宏任务队列
7. new Promise 立即执行，打印出 promise1
8. 执行到 res("promise2") 函数调用，就是 Promise.then。放到微任务队列
9. asyncFunction 函数就执行完毕， 把后面的打印 async2 会放到微任务队列
10. 然后打印出立即执行函数的 then 方法 foo.then
11. 最后执行打印 end
12. 开始执行微任务的队列 打印出第一个 promise2
13. 然后打印第二个 async2
14. 微任务执行完毕，执行宏任务 打印第一个 setTimeout1
15. 执行第二个宏任务 打印 setTimeout2

![ ](/img/interview/thread.jpg)

### 17.前端模块化

前端模块化就是复杂的文件编程一个一个独立的模块，比如 js 文件等等，分成独立的模块有利于重用
（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了 commonJS 规范，
AMD，CMD 规范等等，以及用于 js 打包（编译等处理）的工具 webpack。

### 18.setTimeout 最小执行时间是多少

html5 规定的内容：
setTimeout 最小执行时间是 4ms
setInterval 最小执行时间是 10ms

### 19.包管理工具

> 常见属性

- name: 项目名称
- version: 项目版本号
- description：描述信息，很多时候作为项目的基本描述
- main: 程序入口
- scripts: 用于配置一些脚本命令，以键值对形式存在
- author：作者相关信息
- license: 开源协议
- private: 当前项目是否私有
- dependencies: 记录开发坏境还是生成环境都需要依赖的包
- devDependencies: 记录生成环境不需要的，如 webpack、babel 等

> npm install 原理

![ ](/img/interview/npm.jpg)

### 20.强类型语言和弱类型语言的区别

- 强类型语言：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java 和 C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。
- 弱类型语言：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScripti 语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如 JavaScript 是弱类型定义的，在 JavaScript 中就可以将字符串 12'和整数 3 进行连接得到字符串'123'，在相加的时候会进行强制类型转换。

两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。

### 21.解释性语言和编译型语言的区别

- 解释型语言
    使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下
  - 解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；
  - 只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；
  - JavaScript、.Python 等属于解释型语言。
- 编译型语言
    使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成河被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如 eX 格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行 eXe 文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：
  - 一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；
  - 与特定平台相关，一般无法移植到其他平台；
  - C、C++等属于编译型语言。

两者主要区别在于：前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。

### 22.异步编程的实现方式

- 回调函数

  - 优点：简单、容易理解
  - 缺点：不利于维护，代码耦合高

- 事件监听(采用时间驱动模式，取决于某个事件是否发生)

  - 优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数
  - 缺点：事件驱动型，流程不够清晰

- 发布/订阅(观察者模式)

类似于事件监听，但是可以通过‘消息中心‘，了解现在有多少发布者，多少订阅者

- Promise 对象

  - 优点：可以利用 then 方法，进行链式写法；可以书写错误时的回调函数；
  - 缺点：编写和理解，相对比较难

- Generator 函数

  - 优点：函数体内外的数据交换、错误处理机制
  - 缺点：流程管理不方便

- async 函数

  - 优点：内置执行器、更好的语义、更广的适用性、返回的是 Promise 、结构清晰。
  - 缺点：错误处理机制

### 23.token 存储在哪

token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串。

1. 存在 localstorage 里，后期每次请求接口都需要将它当作一个字段传给后端
2. 存 cookie 中，会自动发送，缺点就是不能跨域

如果存在 localstorage 中，容易被 XSS 共计，但是如果做好了对应措施，利大于弊
如果存在 cookie 中会有 CSRF 攻击

## 四、原型与原型链

### 1.原型与原型链

原型就是一个普通对象，他是构造函数的实例共享属性和方法；所有实例中引用的原型都是同一个对象。使用 prototype 可以把方法挂载原型上，内存只保存一份
**proto**可以理解为指针。实例对象中的属性，指向了构造函数的原型（protortpe）
一个实例对象在调用属性和方法的时候，会一次从实例本身、构造函数原型、原型的原型上去查找

![ ](/img/interview/proto.jpg)

### 2.继承

1. 原型链继承
2. 借用构造函数继承
3. 组合式继承
4. ES6 的 class 继承

#### 原型链继承

```js
function Super(){ this.a=1 }
Super.prototype.say = function(){ console.log(‘hhh’) }
function Sub(){}
Sub.prototype = new Super()

const test = new Sub()
console.log( test.say() )// hhh
```

优点：通过原型继承多个引用类型的属性和方法
缺点：Sub 原型变成了 Super 的实例，如果 Super 的实例某个属性是引用值，该引用值就会被应用到所有 Sub 创建的实例中去，会有污染问题。

#### 盗用构造函数(构造函数模式+call)

```js
function Super = function(){ this.a = 1 }
function Sub = function(){
       Super.call(this)
       this.b = 2
}

const test = new Sub()
```

优点：每个实例都会有自己的 a 属性，哪怕是引用值也不会被污染
缺点：Super 构造函数中的方法在每个实例上都要创建一遍（除非该方法声明提到全局）；Sub 的实例无法访问 Super 原型上的方法

#### 组合继承(原型继承+盗用构造函数继承)

```js
function Super(){ this.a=[1,2] }
Super.prototype.say = function(){ console.log(‘hhh’) }
function Sub(){
    Super.call(this)
    this b=2
}
Sub.prototype = new Super()
 
const test1 = new Sub()
console.log( test1.say() )// hhh
test1.a.push(3)
console.log(test1.a)// [1,2,3]
const test2 = new Sub()
console.log(test2.a)// [1,2]
```

优点：可以在子类构造函数中向父类传参数,父类的引用属性不会被共享
缺点：子类不能访问父类原型上定义的方法（即不能访问 Parent.prototype 上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化

#### 原型式继承

```js
// es5
const obj = { a:1 }
function createObj(o){
    const Fn(){}
    Fn.prototype = o
    return new Fn()
}
const test = createObj(obj)

// es6
const obj = { a:1 }
const test = Object.create(obj)
```

优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性
缺点：由于是浅克隆，所以实例共享的对象属性如果是引用值，会受污染。

#### 寄生式继承(构造函数模式+工厂模式)

```js
function createObj(o){
    let clone = objectCopy(o)
    clone.say=function(){
        console.log(‘hhh’)
    }
    return clone
}

const obj = { a:1 }
const test = createObj(obj)
```

优点：根据一个对象克隆创建另一个对象，并增强对象
缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍

#### 寄生式组合继承(盗用构造函数继承 + 原型式继承)

```js
function Super(){ this.a=[1,2] }
Super.prototype.say = function(){ console.log(‘hhh’) }
function Sub(){
    Super.call(this)
    this b=2
}

Sub.prototype = Object.create(Super.prototype)
Sub.prototype.constructor = Sub

const test = new Sub()
```

优点：集合了【原型式继承】和【盗用构造函数继承】的优点，效率比【组合继承】更高。

## 五、this/call/apply/bind

### 1.this 指向

1. 全局对象中的 this 指向 window
2. 全局作用域或普通函数中 this 指向全局 window
3. 严格模式下，独立调用函数中的 this 指向 undefined
4. this 永远指向最后调用它的那个对象（箭头函数除外）
5. new 关键词改变了 this 指向
6. apply,call,bind 可以改变 this 指向（箭头函数除外）
7. 箭头函数中的 this 的指向在定义的时候就已经确定了，看外层是否有函数，有就是外层函数的 this，没有就是 window
8. 匿名函数中的 this 永远指向 window，匿名函数的指向环境具有全局性

> 绑定规则

- 默认绑定

```js
console.log(this) // window
function a() {
    console.log(this)
}
a() // window

var o = {
    a: 10,
    b: {
        fn: function () {
            console.log(this.a)
        },
    },
}
o.b.fn() // this的上一级对象为b，b内部并没有a变量的定义，所以输出undefined

var o = {
    a: 10,
    b: {
        a: 12,
        fn: function () {
            console.log(this.a)
        },
    },
}
var j = o.b.fn
j() //undefined this永远指向的是最后调用它的对象，虽然fn是对象b的方法，但是fn赋值给j时候并没有执行，所以最终指向window

function test(fn) {
    fn()
}
test(o.b.fn) // window
```

- 隐式绑定

```js
function foo() {
    console.log(this)
}
let obj = {
    bar: foo,
}
obj.bar() // obj
```

- new 绑定

```js
function foo() {
    console.log(this)
}
new foo() // foo
```

- 显式绑定

call 传的是一个参数列表
apply 传递一个数组
bind 传参后不会立即执行，会返回一个改变了 this 指向的函数，这个函数还是可以传参的

```js
let obj = {
    name: '123',
}
function foo(name, age, height) {
    console.log(this)
    console.log(name)
}
foo('123', 18, 1.88) // window
foo.call(obj, '789', 2, 5) // obj
foo.apply(obj, ['456', 10, 2]) // obj
let bar = foo.bind(obj, '890', 12, 5)
bar()

var id = 66
function fn5() {
    setTimeout(() => {
        console.log(this.id)
    }, 100)
}
fn5({ id: 2 } // 66
fn5.call({ id: 22 }) //箭头函数没有作用域 call后 22
```

> 内置函数的 this

```js
setTimeout(function () {
    console.log(this) // window
}, 1000)

let btn = document.querySelector('button')
btn.addEventListener('click', function () {
    console.log(this) // button
})

let names = ['1', '2', '3']
names.forEach(function (item) {
    console.log(this) // window
})
names.forEach(function (item) {
    console.log(this) // 'aaa'
}, 'aaa')
```

> 优先级

new（new 绑定和 call、apply 不允许同时使用）>bind>apply/call>隐式绑定>默认绑定

> 面试题

- 面试题 1

```js
var name = 'luo'
var person = {
    name: 'person',
    sayName: function () {
        console.log(this.name)
    },
}
function sayName() {
    var sss = person.sayName
    sss() // 默认绑定 window luo
    person.sayName() // 隐式绑定 person person
    ;(b = person.sayName)() // 简介函数引用 window luo
}
sayName()
```

- 面试题 2

```js
var name = 'luo'
var person1 = {
    name: 'person1',
    foo1: function () {
        console.log(this.name)
    },
    f002: () => console.log(this.name),
    foo3: function () {
        return function () {
            console.log(this.name)
        }
    },
    foo4: function () {
        return () => {
            console.log(this.name)
        }
    },
}
var person2 = {
    name: 'person2',
}
person1.foo1() // 隐式绑定 person1
person1.foo1.call(person2) // 显式绑定 person2
person1.f002() // window luo
person1.f002.call(person2) // window luo
person1.foo3()() // 默认绑定 window luo
person1.foo3.call(person2)() // 默认绑定 window luo
person1.foo3().call(person2) // person2
person1.foo4()() // 隐式绑定 person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1
```

- 面试题 3

```js
var name = 'luo'
function Person(name) {
    this.name = name
    this.foo1 = function () {
        console.log(this.name)
    }
    this.f002 = () => console.log(this.name)
    this.foo3 = function () {
        return function () {
            console.log(this.name)
        }
    }
    this.foo4 = function () {
        return () => {
            console.log(this.name)
        }
    }
}
var person1 = new Person('person1')
var person2 = new Person('person2')
person1.foo1() // 隐式绑定 person1
person1.foo1.call(person2) // 显式绑定 person2
person1.f002() // person1
person1.f002.call(person2) // person1
person1.foo3()() // 默认绑定 window luo
person1.foo3.call(person2)() // 默认绑定 window luo
person1.foo3().call(person2) // person2
person1.foo4()() // 隐式绑定 person1
person1.foo4.call(person2)() // person2
person1.foo4().call(person2) // person1
```

- 面试题 4

```js
var name = 'luo'
function Person(name) {
    this.name = name
    this.obj = {
        name: 'obj',
        foo1: function () {
            return function () {
                console.log(this.name)
            }
        },
        foo2: function () {
            return () => {
                console.log(this.name)
            }
        },
    }
}
var person1 = new Person('person1')
var person2 = new Person('person2')
person1.obj.foo1()() // 默认绑定 luo
person1.obj.foo1.call(person2)() // 默认绑定 luo
person1.obj.foo1().call(person2) // person2

person1.obj.foo2()() // obj
person1.obj.foo2.call(person2)() // person2
person1.obj.foo2().call(person2) // obj
```

### 2.箭头函数的 this 指向哪⾥？

箭头函数不同于传统 JavaScript 中的函数，箭头函数并没有属于⾃⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的 this，所以是不会被 new 调⽤的，这个所谓的 this 也不会被改变。

可以⽤ Babel 理解⼀下箭头函数:

```js
// ES6
const obj = {
    getArrow() {
        return () => {
            console.log(this === obj)
        }
    },
}
```

转化后：

```js
// ES5，由 Babel 转译
var obj = {
    getArrow: function getArrow() {
        var _this = this
        return function () {
            console.log(_this === obj)
        }
    },
}
```

### 3.call 和 apply 的区别？

它们的作用一模一样，区别仅在于传入参数的形式的不同。

- apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，appy 方法把这个集合中的元素作为参数传递给被调用的函数。
- cal 传入的参数数量不固定，跟 appy 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。

### 4.手写 call、apply、bind

```js
Function.prototype.MyCall = function (context) {
    if (typeof this !== 'function') {
        throw new Error('type error')
    }
    if (context === null || context === undefined) {
        // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)
        context = window
    } else {
        // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象
        context = Object(context)
    }
    // 使用Symbol 来确定唯一
    const fnSym = Symbol()
    //模拟对象的this指向
    context[fnSym] = this
    // 获取参数
    const args = [...arguments].slice(1)
    //绑定参数 并执行函数
    const result = context[fnSym](...args)
    //清除定义的this
    delete context[fnSym]
    // 返回结果
    return result
}

Function.prototype.MyApply = function (context) {
    if (typeof this !== 'function') {
        throw new Error('type error')
    }
    if (context === null || context === undefined) {
        // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)
        context = window
    } else {
        // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象
        context = Object(context)
    }
    // 使用Symbol 来确定唯一
    const fnSym = Symbol()
    //模拟对象的this指向
    context[fnSym] = this
    // 获取参数
    const args = [...arguments][1]
    //绑定参数 并执行函数 由于apply 传入的是一个数组 所以需要解构
    const result =
        arguments.length > 1 ? context[fnSym](...args) : context[fnSym]()
    //清除定义的this
    delete context[fnSym]
    // 返回结果  //清除定义的this
    return result
}

Function.prototype.MyBind = function (context) {
    if (typeof this !== 'function') {
        throw new Error('type error')
    }
    if (context === null || context === undefined) {
        // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window)
        context = window
    } else {
        // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象
        context = Object(context)
    }
    //模拟对象的this指向
    const self = this
    // 获取参数
    const args = [...arguments].slice(1)
    // 最后返回一个函数 并绑定 this 要考虑到使用new去调用，并且bind是可以传参的
    return function Fn(...newFnArgs) {
        if (this instanceof Fn) {
            return new self(...args, ...newFnArgs)
        }
        return self.apply(context, [...args, ...newFnArgs])
    }
}
```

## 六、执行上下文、作用域链、闭包

### 1.闭包的理解

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

```js
function a() {
    let a1 = 1
    return function () {
        return a1
    }
}
```

闭包有两个常用的用途；

- 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
- 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

### 2.闭包形成条件

1. 函数嵌套
2. 内部函数引用外部函数的局部变量

### 3.闭包的存在意义

1. 可以读取函数内部的变量
2. 可以使变量的值长期保存在内存中，生命周期比较长。
3. 可用来实现 JS 模块（JQuery 库等）

- 经典面试题：循环中使用闭包解决 var 定义函数的问题

```js
for (var i; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
```

首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 ⅰ 就是 6 了，所以会输出一堆 6。解决办法有三种：

- 第一种是使用闭包的方式

```js
for (var i 1;i <5;i++){
    (function(j){
        setTimeout (function timer(){
            console.log(j)
        },j*1000)
    })(i)
}
```

- 第二种就是使用 set Timeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。

```js
for (var i = 1; i <= 5; i++) {
    setTimeout(
        function timer(j) {
            console.log(j)
        },
        i * 1000,
        i
    )
}
```

- 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式

```js
for (let = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, 1 * 1000)
}
```

### 4.作用域

```js
function Foo() {
    getName = function () {
        console.log(1)
    }
    return this
}
Foo.getName = function () {
    console.log(2)
}
Foo.prototype.getName = function () {
    console.log(3)
}
var getName = function () {
    console.log(4)
}
function getName() {
    console.log(5)
}
Foo.getName()
getName()
Foo().getName()
getName()
new Foo.getName()
new Foo().getName()
new new Foo().getName()
```

- 执行 Foo.getName(), 执行 Foo 函数对象上的的静态方法。打印出 2
- 执行 getName()， 就是执行的 getName 变量的函数。打印 4
  - 为什么这里是 执行的 变量 getName，而不是函数 getName 呢。这得归功于 js 的预编译 js 在执行之前进行预编译，会进行 函数提升 和 变量提升,所以函数和变量都进行提升了，但是函数声明的优先级最高，会被提升至当前作用域最顶端。当在执行到后面的时候会导致 getName 被重新赋值，就会把执行结果为 4 的这个函数赋值给变量
- 执行 Foo().getName()， 调用 Foo 执行后返回值上的 getName 方法。 Foo 函数执行了，里面会给外面的 getName 函数重新赋值，并返回了 this。 也就是执行了 this.getName。所以打印出了 1
- 执行 getName()， 由于上一步，函数被重新赋值。所以这次的结果和上次的结果是一样的，还是为 1
- 执行 new Foo.getName()， 这个 new 其实就是 new 了 Foo 上面的静态方法 getName 所以是 2。 当然如果你们在这个函数里面打印 this 的话，会发现指向的是一个新对象 也就是 new 出来的一个新对象
  - 可以把 Foo.getName()看成一个整体，因为这里 . 的优先级比 new 高
- 执行 new Foo().getName()，这里函数执行 new Foo() 会返回一个对象，然后调用这个对象原型上的 getName 方法， 所以结果是 3
- 执行 new new Foo().getName(), 这个和上一次的结果是一样，上一个函数调用后并咩有返回值，所以在进行 new 的时候也没有意义了。 最终结果也是 3

### 5.对作用域、作用域链的理解

#### 全局作用域和函数作用域

（1）全局作用域

- 最外层函数和最外层函数外面定义的变量拥有全局作用域
- 所有未定义直接赋值的变量自动声明为全局作用域
- 所有window对象的属性拥有全局作用域
- 全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。

（2）函数作用域

- 函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到
- 作用域是分层的，内层作用域可以访问外层作用域，反之不行

#### 块级作用域

- 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）
- let和const声明的变量不会有变量提升，也不可以重复声明
- 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。

#### 作用域链

在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。

当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。

### 6.对执行上下文的理解

#### 执行上下文类型

- （1）全局执行上下文

任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。

- （2）函数执行上下文

当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。

- （3）**eval**函数执行上下文

执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。

#### 执行上下文栈

- JavaScript引擎使用执行上下文栈来管理执行上下文
- 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。

```js
let a = 'Hello World!';
function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}
function second() {
  console.log('Inside second function');
}
first();
//执行顺序
//先执行second(),在执行first()
```

#### 创建执行上下文

创建执行上下文有两个阶段：创建阶段和执行阶段

- 创建阶段
  - this绑定
    - 在全局执行上下文中，this指向全局对象（window对象）
    - 在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined
  - 创建词法环境组件
    - 词法环境是一种有标识符——变量映射的数据结构，标识符是指变量/函数名，变量是对实际对象或原始数据的引用。
    - 词法环境的内部有两个组件：加粗样式：环境记录器:用来储存变量个函数声明的实际位置外部环境的引用：可以访问父级作用域
  - 创建变量环境组件
    - 变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。
- 执行阶段

此阶段会完成对变量的分配，最后执行完代码。

简单来说执行上下文就是指：

在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。

● 全局上下文：变量定义，函数声明
● 函数上下文：变量定义，函数声明，this，arguments

## 七、Promise

### 1.对Promise的理解

`Promise`是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。

所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，`Promise` 是一个对象，从它可以获取异步操作的消息。`Promise` 提供统一的 API，各种异步操作都可以用同样的方法进行处理。

- `Promise`的实例有三个状态:
  - `Pending`（进行中）
  - `Resolved`（已完成）
  - `Rejected`（已拒绝）

当把一件事情交给`promise`时，它的状态就是`Pending`，任务完成了状态就变成了`Resolved`、没有完成失败了就变成了`Rejected`。

- `Promise`的实例有两个过程：
  - `pending` -> `fulfilled` : `Resolved`（已完成）
  - `pending` -> `rejected`：`Rejected`（已拒绝）

注意：一旦从进行状态变成为其他状态就永远不能更改状态了。

- `Promise`的特点：
  - 对象的状态不受外界影响。`promise`对象代表一个异步操作，有三种状态，`pending`（进行中）、`fulfilled`（已成功）、`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是`promise`这个名字的由来——“承诺”；
  - 一旦状态改变就不会再变，任何时候都可以得到这个结果。`promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`，从`pending`变为`rejected`。这时就称为`resolved`（已定型）。如果改变已经发生了，你再对`promise`对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。

- `Promise`的缺点：
  - 无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。
  - 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
  - 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

总结： `Promise` 对象是异步编程的一种解决方案，最早由社区提出。`Promise` 是一个构造函数，接收一个函数作为参数，返回一个 `Promise` 实例。一个 `Promise` 实例有三种状态，分别是`pending`、`resolved` 和 `rejected`，分别代表了进行中、已成功和已失败。实例的状态只能由 `pending` 转变 `resolved` 或者`rejected` 状态，并且状态一经改变，就凝固了，无法再被改变了。

状态的改变是通过 `resolve()` 和 `reject()` 函数来实现的，可以在异步操作结束后调用这两个函数改变 `Promise` 实例的状态，它的原型上定义了一个 `then` 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。

注意： 在构造 `Promise` 的时候，构造函数内部的代码是立即执行的

### 2.Promise解决了什么问题

在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：

```js
let fs = require('fs')
fs.readFile('./a.txt','utf8',function(err,data){
  fs.readFile(data,'utf8',function(err,data){
  
    fs.readFile(data,'utf8',function(err,data){
      console.log(data)
    })
  })
})
```

上面的代码有如下缺点：

- 后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个`ajax`请求嵌套的情况，代码不够直观。
- 如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。

`Promise`出现之后，代码变成这样：

```js
let fs = require('fs')
function read(url){
  return new Promise((resolve,reject)=>{
    fs.readFile(url,'utf8',function(error,data){
      error && reject(error)
      resolve(data)
    })
  })
}
read('./a.txt').then(data=>{
  return read(data) 
}).then(data=>{
  return read(data)  
}).then(data=>{
  console.log(data)
})
```

这样代码看起了就简洁了很多，解决了地狱回调的问题。

### 3.Promise.all和Promise.race的区别的使用场景

#### Promise.all

`Promise.all`可以将多个`Promise`实例包装成一个新的`Promise`实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被`reject`失败状态的值。
`Promise.all`中传入的是数组，返回的也是是数组，并且会将进行映射，传入的`promise`对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。
需要注意，`Promise.all`获得的成功结果的数组里面的数据顺序和`Promise.all`接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用`Promise.all`来解决。

#### Promise.race

顾名思义，`Promse.race`就是赛跑的意思，意思就是说，`Promise.race([p1, p2, p3])`里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：

```js
Promise.race([promise1,timeOutPromise(5000)]).then(res=>{})
```

### 4.对async/await 的理解

async/await其实是Generator 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么：

```js
async function testAsy(){
   return 'hello world';
}
let result = testAsy(); 
console.log(result)
```

所以，`async` 函数返回的是一个 `Promise` 对象。`async` 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 `Promise` 对象，如果在函数中 `return` 一个直接量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成 `Promise` 对象。

`async` 函数返回的是一个 `Promise` 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：`then()` 链来处理这个 `Promise` 对象，就像这样：

```js
async function testAsy(){
   return 'hello world'
}
let result = testAsy() 
console.log(result)
result.then(v=>{
    console.log(v)   // hello world
})
```

那如果 `async` 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。

联想一下 `Promise` 的特点——无等待，所以在没有 await 的情况下执行 `async` 函数，它会立即执行，返回一个 `Promise` 对象，并且，绝不会阻塞后面的语句。这和普通返回 `Promise` 对象的函数并无二致。

注意：`Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 `Promise` 实例。

### 5.await 到底在等啥？

`await` 在等待什么呢？ 一般来说，都认为 `await` 是在等待一个 `async` 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。

因为 `async` 函数返回一个 `Promise` 对象，所以 `await` 可以用于等待一个 `async` 函数的返回值——这也可以说是 `await` 在等 `async` 函数，但要清楚，它等的实际是一个返回值。注意到 `await` 不仅仅用于等 `Promise` 对象，它可以等任意表达式的结果，所以，`await` 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：

```js
function getSomething() {
    return "something";
}
async function testAsync() {
    return Promise.resolve("hello async");
}
async function test() {
    const v1 = await getSomething();
    const v2 = await testAsync();
    console.log(v1, v2);
}
test();
```

`await` 表达式的运算结果取决于它等的是什么。

- 如果它等到的不是一个 `Promise` 对象，那 `await` 表达式的运算结果就是它等到的东西。
- 如果它等到的是一个 `Promise` 对象，`await` 就忙起来了，它会阻塞后面的代码，等着 `Promise` 对象 `resolve`，然后得到 `resolve` 的值，作为 `await` 表达式的运算结果。

```js
function testAsy(x){
   return new Promise(resolve=>{setTimeout(() => {
       resolve(x);
     }, 3000)
    }
   )
}
async function testAwt(){    
  let result =  await testAsy('hello world');
  console.log(result);    // 3秒钟之后出现hello world
  console.log('cuger')   // 3秒钟之后出现cug
}
testAwt();
console.log('cug')  //立即输出cug
```

这就是 `await` 必须用在 `async` 函数中的原因。`async` 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 `Promise` 对象中异步执行。`await`暂停当前`async`的执行，所以'cug''最先输出，hello world'和‘cuger’是3秒钟后同时出现的。

### 6.async/await的优势

单一的 `Promise` 链并不能发现 `async/await` 的优势，但是，如果需要处理由多个 `Promise` 组成的 `then` 链的时候，优势就能体现出来了（很有意思，`Promise` 通过 `then` 链来解决多层回调的问题，现在又用 `async/await` 来进一步优化它）。

假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 `setTimeout` 来模拟异步操作：

```js
/**
 * 传入参数 n，表示这个函数执行的时间（毫秒）
 * 执行的结果是 n + 200，这个值将用于下一步骤
 */
function takeLongTime(n) {
    return new Promise(resolve => {
        setTimeout(() => resolve(n + 200), n);
    });
}
function step1(n) {
    console.log(`step1 with ${n}`);
    return takeLongTime(n);
}
function step2(n) {
    console.log(`step2 with ${n}`);
    return takeLongTime(n);
}
function step3(n) {
    console.log(`step3 with ${n}`);
    return takeLongTime(n);
}
```

现在用 `Promise` 方式来实现这三个步骤的处理：

```js
function doIt() {
    console.time("doIt");
    const time1 = 300;
    step1(time1)
        .then(time2 => step2(time2))
        .then(time3 => step3(time3))
        .then(result => {
            console.log(`result is ${result}`);
            console.timeEnd("doIt");
        });
}
doIt();
// c:\var\test>node --harmony_async_await .
// step1 with 300
// step2 with 500
// step3 with 700
// result is 900
// doIt: 1507.251ms
```

输出结果 `result` 是 `step3()` 的参数 `700 + 200 = 900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。

如果用 `async/await` 来实现呢，会是这样：

```js
async function doIt() {
    console.time("doIt");
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time2);
    const result = await step3(time3);
    console.log(`result is ${result}`);
    console.timeEnd("doIt");
}
doIt();
```

结果和之前的 `Promise` 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样

### 7.async/await 如何捕获异常

```js
async function fn(){
    try{
        let a = await Promise.reject('error')
    }catch(error){
        console.log(error)
    }
}
```

## 八、手写

### 1.递归求和

```js
function add(num1, num2) {
    let num = num1 + num2
    if (num2 + 1 > 100) {
        return num
    } else {
        return add(num, num2 + 1)
    }
}
let sum = add(1, 2)
console.log(sum)
```

### 2.通过 es6 互换值

```js
let a = 1
let b = 2
;[a, b] = [b, a]
console.log(a, b) //2 1
```

### 3.去重

- 方法一

```js
let arr = [1, 2, 33, 4, 5, 3, 2, 1, 5, 6, 4, 3]

// 方法一
function fn(arr) {
    let newArr = []
    for (let i = 0; i < arr.length; i++) {
        if (newArr.indexOf(arr[i]) === -1) {
            newArr.push(arr[i])
        }
    }
    return newArr
}
let a = fn(arr)
console.log(a) // [1, 2, 33, 4, 5, 3, 6]
```

- 方法二

```js
let arr = [1, 2, 33, 4, 5, 3, 2, 1, 5, 6, 4, 3]

let item = [...new Set(arr)]
console.log(item) // [1, 2, 33, 4, 5, 3, 6]
```

### 4.数组扁平化

- 方法一

```js
function flatten(array) {
    let result = []
    array.forEach((item) => {
        if (Array.isArray(item)) {
            const flatterItem = flatten1(item)
            result = result.concat(flatterItem)
        } else {
            result = result.concat(item)
        }
    })
    return result
}

console.log(flatten([1, 2, [3, [4, [5, [6]]]]]))
```

- 方法二

```js
let arr = [1, 2, [3, [4, [5, [6]]]]]
console.log(arr.flat(Infinity))
```

### 5.将数组扁平化且去除重复的元素，最后升序输出

```js
let arr = [1, [1, [2]], [3, 4], 7, 4, [2, 3, [4, 5, [2, 2, 1, 5, 4, 3, 8]]]]

function fn(arr) {
    let newArr = arr.flat(Infinity)
    newArr = [...new Set(newArr)]
    return newArr.sort((a, b) => a - b)
}
console.log(fn(arr)) //[1, 2, 3, 4, 5, 7, 8]
```

### 6.找出数组中出现最多的数字

```js
function findMostRepetitionsNumber(arr) {
    let num = null
    let count = 1
    const obj = {}
    for (let i = 0; i < arr.length; i++) {
        if (!obj[arr[i]]) {
            obj[arr[i]] = 1
        } else {
            obj[arr[i]] += 1
            if (obj[arr[i]] > count) {
                count = obj[arr[i]]
                num = arr[i]
            }
        }
    }
    return {
        num,
        count,
    }
}

const arr = [3, 5, 6, 6, 6, 6, 5, 9, 8, 10, 5, 7]

console.log(findMostRepetitionsNumber(arr))
```

### 7.如何拦截全局 Promise reject，但并没有设定 reject 处理器 时候的错误

```js
// 使用Try catch 只能拦截try语句块里面的
try {
    new Promise((resolve, reject) => {
        reject('WTF 123')
    })
} catch (e) {
    console.log('e', e)
    throw e
}

// 使用 unhandledrejection 来拦截全局错误  （这个是对的）
window.addEventListener('unhandledrejection', (event) => {
    event && event.preventDefault()
    console.log('event', event)
})
```

### 8.大文件上传

分片上传

1. 把需要上传的文件按照一定的规则，分割成相同大小的数据块
2. 初始化一个分片上传任务，返回本次分片上传的唯一标识
3. 按照一定的规则把各个数据块上传
4. 发送完成后，服务端后判断数据上传的完整性，如果完整，那么就把数据库合并成成原始文件

### 9.手写实现 sleep

```js
;(async () => {
    console.log('start')
    await sleep(3000)
    console.log('end')

    function sleep(timer) {
        return new Promise((res) => {
            setTimeout(() => {
                res()
            }, timer)
        })
    }
})()
```

### 10.找到仅在两个数组中出现过一次的数据

```js
var a = [1, 2, 4],
    b = [1, 3, 8, 4]
const newArr = a.concat(b).filter((item, _, arr) => {
    return arr.indexOf(item) === arr.lastIndexOf(item)
})
```

### 11.快速打乱数组

```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
arr.sort(() => Math.random() - 0.5)
//利用sort return 大于等于0不交换位置，小于0交换位置
// [5, 8, 4, 3, 2, 9, 10, 6, 1, 7]
```
