---
title: 计算机网络面试题
icon: markdown
order: 7
date: 2023-02-20
category:
    - 面试
tag:
    - 网络
---

## GET和POST的请求的区别

- 应用场景：GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。
- 是否缓存：因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。
- 发送的报文格式：Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
- 安全性：Get 请求可以将请求的参数放入url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
- 请求长度：浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。
- 参数类型：post 的参数传递支持更多的数据类型。

## POST和PUT请求的区别

- PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）
- POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。可以理解为是创建数据）

## 常见的HTTP请求头和响应头

### HTTP Request Header 常见的请求头

- Accept:浏览器能够处理的内容类型
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding:浏览器能够处理的压缩编码
- Accept-Language:浏览器当前设置的语言
- Connection:浏览器与服务器之间连接的类型
- Cookie:当前页面设置的任何Cookie
- Host:发出请求的页面所在的域
- Referer:发出请求的页面的URL
- User-Agent:浏览器的用户代理字符串

### HTTP Responses Header 常见的响应头

- Date：表示消息发送的时问，时间的描述格式由rfc822定义
- server:服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache- Control：控制HTTP缓存
- content-type:表示后面的文档厲于什么MIME类型

常见的 Content-Type 厲性值有以下四种：

- application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 kev1=val1&key2=val2 的方式进行编码，key 和val 都进行了 URL转码。
- multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。
- application/ison：服务器消息主体是序列化后的 JSON 字符串。
- text/xml：该种方式主要用来提交 xML 格式的数据。

## HTTP状态码304是多好还是少好

服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。

状态码304不应该认为是一种错误，而是对客户端有缓存情况下服务端的一种响应。

搜素引擎蜘蛛会更加青睞内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。

产生较多304状态码的原因：

- 页面更新周期长或不更新
- 纯静态页面或强制生成静态html

304状态码出现过多会造成以下问题：

- 网站快照停止；
- 收录减少；
- 权重下降。

## 常见的HTTP请求方法

- GET：向服务器获取数据；
- POST：将实体提交到指定的资源，通常会造成服务器资源的修改；
- PUT：上传文件，更新数据；
- DELETE：删除服务器上的对象；
- HEAD：获取报文首部，与GET相比，不返回报文主体部分；
- OPTIONS：询问支持的请求方法，用来跨域请求；
- CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；
- TRACE：回显服务器收到的请求，主要用于测试或诊断。

## OPTIONS请求方法及使用场景

OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。

OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。

OPTIONS请求方法的主要用途有两个：

- 荻取服务器支持的所有HTTP请求方法；
- 用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。

## HTTP与HTTPS的区别

- HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；
- HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；
- 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；
- HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。

## GET方法URL长度限制的原因

实际上HTTP协议规范并没有对get方法请求的url'长度进行限制，这个限制是特定的浏览器及服务器对它的限制。

IE对URL长度的限制是2083字节(2K+35)。由于E浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。

下面看一下主流浏览器对get方法中url的长度限制范围：

- Microsoft Internet Explorer (Browser)：E浏览器对UPL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。
- Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。
- Safari (Browser)：URL最大长度限制为 80,000 个宇符。
- Opera (Browser)：URL最大长度限制为 190,000 个字符。
- Google (chrome)：URL最大长度限制为 8182 个字符。

主流的服务器对get方法中url的长度限制范围：

- Apache (Server)：能接受最大url长度为8192个字符。
- Microsoft Internet Information Server(IS)：能接受最大ur的长度为16384个字符。

根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。

## HTTP状态码

|分类|分类描述|
|:--|:--:|
|1**|信息，服务器收到请求，需要请求者继续执行操作|
|2**|成功，操作被成功接受并处理|
|3**|重定向，需要进一步的操作以完成请求|
|4**|客户端错误，请求包含语法错误或无法完成请求|
|5**|服务器错误，服务器在处理请求的过程中发生了错误|

- 2XX(Success成功状态码)
状态码2XX表示请求被正常处理了。
  - 200 OK
表示客户端发来的请求被服务器端正常处理了。
  - 204 No Content
该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。
  - 206 Partial Content
该状态码表示客户端进行了范围请求，而服务器端执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。

- 3XX(Redirection重定向状态码)
3XX响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。
  - 301 Moved Permanently
永久重定向。
该状态码表示请求的资源已经被分配了新的URI,以后应使用资源指定的UR1。新的UR!会在HTTP响应头中的Location首部字段指定。若用户已经把原来的URI保存为书签，此时会按照Location中新的UR重新保存孩书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。
使用场景：
    - 当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。
    - 在搜索引擎的搜索结果中出现了不带www的域名，而带ww的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。

  - 302 Found
临时重定向。
该状态码表示请求的资源被分配到了新的UR,希望用户（本次）能使用新的UR!访问资源。和301 Moved Permanent机y状态码相似，但是302代表的资源不是被永久重定向，只是I临时性质的。也就是说已移动的资源对应的UR将来还有可能发生改变。若用户把UR!保存成书签，但不会像301状态码出现时那样去更新书签，而是仍旧保留返回302状态码的页面对应的UR1。同时，搜索引擎会抓取新的内容而保留日的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。
使用场景：
    - 当我们在做活动时，登录到首页自动重定向，进入活动页面。
    - 未登陆的用户方问用户中心重定向到登录页面。
    - 访问404页面重新定向到首页。

  - 303 See Other
该状态码表示由于清求对应的资源存在着另一个UR!,应使用GET方法定向获取请求的资源。303状态码和302Foud状态码有着相以的功能，但是303状态码明确表示客户端应当采用GET方法获取资源。
303状态码通常作为PUT或POST操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用GET。
注意：
    - 当301、302、303响应状态码返回时，几乎所有的浏览器都会把POST改成GET,并删除请求报文内的主体，之后请求会再次自动发送。
    - 301、302标准是禁止将POST方法变成GET方法的，但实际大家都会这么做。

  - 304 Not Modified
浏览器缓存相关。
该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。
带条件的请求(Http条件请求)：使用Get方法请求，请求报文中包含(if-match、.if-none-match.、if-modified-since、if-unmodified-since、if-range)中任意首部。
状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。
  - 307 Temporary Redirect
307表示临时重定向。该状态码与302Foud有着相同含义，尽管302标准禁止POST变成GET,但是实际使用时还是这样做了。
307会遵守浏览器标准，不会从POST变成GET。但是对于处理清求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向Location的地址POST内容。规范要求浏览器继续向Location的地址POST内容。

- 4XX(Client Error客户端错误状态码)
4XX的响应结果表明客户端是发生错误的原因所在。
  - 400 Bad Request
该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像200OK一样对待该状态码。
  - 401 Unauthorized
该状态码表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败返回含有401的响应必须包含个适用于被请求资源的WWW-Authenticate首部用以质询
(challenge)用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。
以下情况会出现401：
    - 401.1-登录失败。
    - 401.2-服务器配置导致登录失败。
    - 401.3-由于ACL对资源的限制而未获得授权。
    - 401.4-筛选器授权失败。
    - 401.5-1SAPI/CG应用程序授权失败。
    - 401.7-访问被Wb服务器上的URL授权策略拒绝。这个错误代码为lS6.0所专用。
  - 403 Forbidden
该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。
IIS定义了许多不同的403错误，它们指明更为具体的错误原因：
    - 403.1-执行访问被禁止。
    - 403.2-读访问被禁止。
    - 403.3-写访问被禁止。
    - 403.4-要求SSL.
    - 403.5-要求SSL128.
    - 403.6-P地址被拒绝。
    - 403.7-要求客户端证书。
    - 403.8-站点访问被拒绝。
    - 403.9-用户数过多.
    - 403.10-配置无效。
    - 403.11-密码更改。
    - 403.12-拒绝访问映射表。
    - 403.13-客户端证书被吊销。
    - 403.14-拒绝日录列表。
    - 403.15-超出客户端访问许可。
    - 403.16-客户端证书不受信任或无效。
    - 403.17-客户端证书已过期或尚未生效
    - 403.18-在当前的应用程序池中不能执行所请求的URL。这个错误代码为S6.0所专用。
    - 403.19-不能为这个应用程序池中的客户端执行CG1。这个错误代码为S6.0所专用。
    - 403.20-Passport登录失败。这个错误代码为lS6.0所专用。
  - 404 Not Found
该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。
以下情况会出现404：
    - 404.0。(无)-没有找到文件或日录。
    - 404.1-无法在请求的端口上方问Web站点。
    - 404.2-Web服务扩展锁定策略阻止本请求。
    - 404.3-MME映射策略阻止本请求。
  - 405 Method Not Allowed
该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET和HEAD方法，服务器应该总是允许客户端进行方问。客户端可以通过OPTIONS方法（预检）来查看服务器允许的访问方法

- 5XX(Server Error服务器错误状态码)
5XX的响应结果表明服务器本身发生错误
  - 500 Internal Server Error
该状态码表明服务器端在执行请求时发生了错误。也有可能是Wlb应用存在的bug或某些临时的故障。
  - 502 Bad Gateway
该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502错误通常不是客户端能够修复的，而是需要由途经的Wb服务器或者代理服务器对其进行修复。
以下情况会出现502：
    - 502.1-CG
(通用网关接口)应用程序超时。
    - 502.2-CG引
(通用网关接口)应用程序出措。
  - 503 Service Unavailable
该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除
以上状况需要的时间，最好写入RetryAfter首部字段再返回给客户端。
使用场景：
    - 服务器停机维护时，主动用503响应请求；
    - nginx设置限速，超过限速，会返回503。
  - 504 Gateway Timeout
该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP1.1中新加入的。
使用场景：代码执行时间超时，或者发生了死循环。

- 总结
  - 2XX成功
    - 200OK,表示从客户端发来的请求在服务器端被正确敔处理
    - 204 No content,表示请求成功，但响应报文不含实体的主体部分
    - 205 Reset Content,表示请求成功，但响应报文不含实体的主体部分，但是与204响应不同在于要求请求方重置内容
    - 206 Partial Content,进行范围请求
  - 3XX重定向
    - 301 moved permanently,永久性重定向，表示资源已被分配了新的URL
    - 302 found,临时性重定向，表示资源临时被分配了新的URL
    - 303 see other,表示资源存在着另一个URL,应使用GET方法获取资源
    - 304 not modified,表示服务器允许访问资源，但因发生请求未满足条件的情况
    - 307 temporary redirect,临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求
  - 4XX客户端错误
    - 400 bad request,.请求报文存在语法错误
    - 401 unauthorized,表示发送的请求需要有通过HTTP认证的认证信息
    - 403 forbidden,表示对请求资源的访问被服务器拒绝
    - 404 not found,表示在服务器上没有找到清求的资源
  - 5XX服务器错误
    - 500 internal sever error,表示服务器端在执行请求时发生了错误
    - 501 Not Implemented,表示服务器不支持当前请求所需要的某个功能
    - 503 service unavailable,表明服务器暂时处于超负载或正在停机维护，无法处理请求

## 对keep-alive的理解

HTTP1.0中默认是在每次请求/应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是短连接。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive.功能避免了建立或者重新建立连接，这就是长连接。其使用方法如下：

- HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive）,所以要想连接得到保持，必须手动配置发送Connection:keep-alive字段。若想断开keep-alive连接，需发送Connection:close字段，
- HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送Connection:close首部字段。

Keep-Alive的建立过程：

- 客户端向服务器在发送请求报文同时在首部添加发送Connection字段
- 服务器收到请求并处理Connection字段
- 服务器回送Connection:Keep-Alive:字段给客户端
- 客户端接收到Connection字段
- Keep-Alie连接建立成功

服务端自动断开过程（也就是没有keep-alive）:

- 客户端向服务器只是发送内容报文（不包含Connection字段）
- 服务器收到请求并处理
- 服务器返回客户端请求的资源并关闭连接
- 客户端接收资源，发现没有Connection字段，断开连接

客户端请求断开连接过程：

- 客户端向服务器发送Connection:close字段
- 服务器收到请求并处理connection字段
- 服务器回送响应资源并断开连接
- 客户端接收资源并断开连接

开启Keep-Alive的优点：

- 较少的CPU和内存的使用（由于同时打开的连接的减少了）；
- 允许请求和应答的HTTP管线化，
- 降低拥塞控制(TCP连接减少了)；
- 减少了后续请求的延迟（无需再进行握手）；
- 报告错误无需关闭TCP连；

开启Keep-Alive的缺点：

- 长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。

## 页面有多张图片，HTTP是怎样的加载表现？

- 在HTTP1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。
- 在HTTP2下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。

## HTTP请求报文的是什么样的？

请求报文有4部分组成：

- 请求行
- 请求头部
- 空行
- 请求体
![ ](/img/interview/http.jpg)

(1)请求行包括：请求方法字段、URL字段、HTTP协议版本字段。它们用空格分隔。例如，GET /index.html HTTP/1.1.
(2)请求头部：请求头部由关键字值对组成，每行一对，关键字和值用英文冒号“：”分隔

- User-Agent:产生请求的浏览器类型，
- Accept:客户端可识别的内容类型列表。
- Host:请求的主机名，允许多个域名同处一个P地址，即虚拟主机。
(3)请求体：post put等请求携带的数据
![ ](/img/interview/http2.jpg)

- 响应行：由网络协议版本，状态码和状态码的原因短语组成，例如HTTP/1.1200OK。
- 响应头：响应部首组成
- 响应体：服务器响应的数据

## HTTP响应报文的是什么样的？

请求报文有4部分组成：

- 响应行
- 响应头
- 空行
- 响应体

## HTTP协议的优点和缺点

HTTP是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用80端口。它使用TCP作为传输层协议，保证了数据传输的可靠性。

- HTTP协议具有以下优点：
  - 支持客户端服务器模式
  - 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
  - 无连接：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
  - 无状态：HTTP协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。
  - 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-type加以标记。
- HTTP协议具有以下缺点：
  - 无状态：HTTP是一个无状态的协议，HTTP服务器不会保存关于客户的任何信息。
  - 明文传输：协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。
  - 不安全
    - 通信使用明文（不加密），内容可能会被窃听；
    - 不验证通信方的身份，因此有可能遭遇伪装：
    - 无法证明报文的完整性，所以有可能已遭篡改：

## URL有哪些组成培部分

以下面的URL为例：`http:www.aspxfans.com:8080/news/index.asp?boardID=5&1D=24618&page=1#name`

从上面的URL可以看出，一个完整的URL包括以下几部分：

- 协议部分：该丸URL的协议部分为htp:”,这代表网页使用的是HTTP协议。在Interneti中可以使用多种协议，如HTTP,FTP等等本例中使用的是HTTP协议。在"HTTP"后面的“P"为分隔符；
- 域名部分：该URL的域名部分为“www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用
- 端口部分：跟在域名后面的是端口，域名和端口之间使用“：”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口(HTTP协议默认端口是80，HTTPS协议默认端口是443)；
- 虚拟目录部分：从域名后的第一个“开始到最后一个“”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“news”,
- 文件名部分：从域名后的最后一个“开始到“？”为止，是文件名部分，如果没有“？”，则是从域名后的最后一个“开始到“#"为止，是文件部分，如果没有“？"和#”，那么从域名后的最后一个“开始到结束，都是文件名部分。本例中的文件名是“ndex.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；
- 锚部分：从“#开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分：
- 参数部分：从“？"开始到#”为止之间的部分为参数赔部分，又称搜索部分、查询部分。本例中的参数部分为“"b0ardD=5&D=24618&page=1”。参数可以允许有多个参数，参数与参数之间用“&"作为分隔符。

## 什么是HTTPS协议？

超文本传输安全协议(Hypertext Transfer Protocol Secure,简称：HTTPS)是一种通过计算机网络进行安全通信的传输协议。HTTPS:经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。

![ ](/img/interview/https.jpg)

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。

安全层的主要职责就是对发起的HTTP请求的数据进行加密操作和对接收到的HTTP的内容进行解密操作。

## TLS/SSL的工作原理

TLS/SSL全称安全传输层协议(Transport Layer Security),是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。
TLS/SSL的功能实现主要依赖三类基本算法：散列函数hash、对称加密、非对称加密。这三类算法的作用如下：

- 基于散列函数验证信息的完整性
- 对称加密算法采用协商的秘钥对数据加密
- 非对称加密实现身份认证和秘钥协商

![ ](/img/interview/https2.jpg)

(1)散列函数hash

常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。

特点：在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。

(2)对称加密

对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题就是如何保证秘必钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘必钥被其他人获取到，那
么整个加密过程就毫无作用了。这就要用到非对称加密的方法。常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。

特点：对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。

(3)非对称加密
非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户，都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称幼加密有一个缺点就是加密的过程很慢，因此比如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。

常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。

特点：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。

综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对祢秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。

## 数字证书是什么？

现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发关给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。

首先使用一种Hash算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称CA）用它的私钥对消息滴要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的Hash算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。

这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。

![ ](/img/interview/https3.jpg)

## HTTPS通信（握手）过程

- 客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。
- 服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。
- 客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服务器。并且还会提供一个前面所有内容的hash的值，用来供服务器检验。
- 服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的hash值来供客户端检验。
- 客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。

5.HTTPS的特点

- HTTPS的优点如下：
  - 使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；
  - 使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；
  - HTTPS,是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本
- HTTPS的缺点如下：
  - HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；
  - HTTPS协议握手阶段比较费时，增加页面的加载时间；
  - SSL证书是收费的，功能越强大的证书费用越高；
  - HTTPS:连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；
  - SSL证书需要绑定IP,不能再同一个P上绑定多个域名。

## HTTPS是如何保证安全的？

先理解两个概念：

- 对称加密：即通信的双方都使用同一个秘钥进行加解密，对称加密虽然很简单性能也好，但是无法解决首次把秘钥发给对方的问题，很容易被黑客拦截秘钥。
- 非对称加密：

私钥+公钥=密钥对

即用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密因为通信双方的手里都有一套自己的密钥对，通信之前双方会先把自己的公钥都先发给对方然后对方再拿着这个公钥来加密数据响应给对方，等到到了对方那里，对方再用自己的私钥进行解密非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。

结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

此时又带来一个问题，中间人问题：

如果此时在客户端和服务器之间存在一个中间人，这个中间人只需要把原本双方通信互发的公钥，换成自己的公钥，这样中间人就可以轻松解密通信双方所发送的所有数据。

所以这个时候需要一个安全的第三方颁发证书(C八)，证明身份的身份，防止被中间人攻击。证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等。

但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。

数字签名就是用CA自带的HASH算法对证书的内容进行HASH得到一个摘要，再用CA的私钥加密，最终组成数字签名。当别人把他的证书发过来的时候，我再用同样的Hash算法，再次生成消息摘要，然后用CA的公钥对数字签名解密，得到CA创建的消息摘要，两者一比，就知道中间有没有被人篡改了。这个时候就能最大程度保证通信的安全了。

## OS七层模型

ISO为了更好的使网络应用更为普及，推出了OS参考模型

![ ](/img/interview/iso.jpg)

- 应用层

OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP,HTTPS,FTP,POP3、SMTP等

- 表示层

表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式
转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。

在项目开发中，为了方便数据传输，可以使用base64对数据进行编解码。如果按功能来划分，base64应该是工作在表示层。

- 会话层

会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程
序之间的服务请求和响应组成。

- 传输层

传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差措控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。

- 网络层

本层通过P寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的P层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。

- 数据链路层

将比特组合成字节，再将字节组合成贞，使用链路层地址（以太网使用M八C地址）来访问介质，并进行差错检测。

网络层与数据链路层的对比，通过上面的描述，我补们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。

- 物理层

实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。

- OSI七层模型通信特点：对等通信

对等通信，为了使数据分组从源传送到目的地，源端OS模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。

## TCP/IP五层协议

TCPP五层议和OS的七层协议对应关系如下：

![ ](/img/interview/TCP.jpg)

- 应用层(application layer):直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如HTTP协议（万维网服务）、FTP协议(文件传输)、SMTP协议（电子邮件）、DNS(域名查询)等。

- 传输层(transport layer):有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：
  - 传输控制协议(Transmission Control Protocol,TCP):提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段(segment);
  - 用户数据报协议(User Datagram Protocol,UDP):提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。
- 网络层(internet layer):有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。
- 数据链路层(data link layer):负责将网络层交下来的P数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）
- 物理层(physical Layer):确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。

从上图中可以看出，TCPP模型比OS模型更加简洁，它把应用层表示层会话层全部整合为了应用层。

在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。

![ ](/img/interview/TCP2.jpg)

在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：

![ ](/img/interview/TCP3.jpg)

同样，TCPP五层议的通信方式也是对等通信：

![ ](/img/interview/TCP4.jpg)

## axios取消请求

- 使用 CancelToken

```js
const { CancelToken, isCanCel } = axios;
const source = CancelToken.source();

axios.get('/user/12345', {
  cancelToken: source.token
}).catch(thrown => {
  if (isCancel(thrown)) {
    // 获取 取消请求 的相关信息
    console.log('Request canceled', thrown.message);
  } else {
    // 处理其他异常
  }
});

axios.post('/user/12345', {
  name: 'new name'
}, {
  cancelToken: source.token
})

// 取消请求。参数是可选的，参数传递一个取消请求的相关信息，在 catch 钩子函数里能获取到
source.cancel('Operation canceled by the user.');
```

- 给构造函数 CancelToken 传递一个 executor 函数作为参数。这种方法的好处是，可以用同一个 cancel token 来取消多个请求

```js
const CancelToken = axios.CancelToken;
let cancel;
axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // 参数 c 也是个函数
    cancel = c;
  })
});
// 取消请求，参数用法同上
cancel();
```

## 什么是WebSoket？

WebSocket 是 html5 新增的一种协议，是一种网络通信协议。WebSocket协议不是一种全新的协议，而是利用 HTTP协议来建立的一种协议。

## websocket 的请求与普通的 http 的请求存在以下几种区别点

- GET请求的地址不是类似/path/，而是以ws://开头的地址；
- 请求头Upgrade: websocket和Connection: Upgrade表示这个连接将要被转换为WebSocket连接；
- Sec-WebSocket-Key是用于标识这个连接，并非用于加密数据；
- Sec-WebSocket-Version指定了WebSocket的协议版本。

## websocket连接的特点

websocket连接最大的特点就是 服务器 可以主动向 客户端发送消息，客户端也可以向服务器端发送消息，是真正平等的对话。

其他的特点如下：

- 建立在 tcp 协议之上，服务器端的实现比较容易
- 与 http具有良好的兼容性，能够通过各种 http 代理服务器
- 数据格式比较轻，性能开销小
- 可以发送文本，也可以发送二进制数据
- 没有同源策略的限制，客户端可以向任意服务器通信
- 协议标识是 ws , 如果加密就是 wss

## websocket 心跳机制

如果在连接后需要长时间保持连接，但又不是一直都在通信，可以在连接中添加心跳机制，每隔一段时间就从客户端发送一个数据给后台，后台再返回一个数据给客户端保持通信。

```js
// 含有心跳的websocket对象
let myWebsocket = {
    ws: null ,
    url:"",
    event: null ,
    init(url , event){
        try{
            if('WebSocket' in window){
                this.ws = new WebSocket( url );
                let a = `<b style="color: #1e7e34">再次连接</b>`;
                $(".resultWrap").append(a);
                this.url = url ;
                this.event = event;
                this.listenerEvent( event ) ;
                this.listenClose();
            }else{
                alert("您的浏览器不支持websocket协议,建议使用新版谷歌、火狐等浏览器，请勿使用IE10以下浏览器，360浏览器请使用极速模式，不要使用兼容模式!");
            }
        }catch(e){
            this.reconnect(url);
            console.log(e);
        }
    },
    listenerEvent(event) {
        let $this = this;
        $this.ws.onopen = function (e) {
            heartCheck.reset();
            heartCheck.start();
            event.open(e);
        };
        $this.ws.onmessage = function (e) {
            heartCheck.reset();
            heartCheck.start();
            event.message(e);
        };
        $this.ws.onclose = function (e) {
            event.close(e);
            $this.reconnect();
        };
        $this.ws.onerror = function (e) {
            $this.reconnect( $this.url );
            event.error(e);
        }
    },
    listenClose(){
        window.onbeforeunload = function () {
            this.ws.close();
        };
        window.onbeforeload = function () {
            this.ws.close();
        }
    },
    reconnect(){
        let $this = this;
        setTimeout(function () {
            $this.init($this.url , $this.event);
        }, 3000);
    },
};

```
