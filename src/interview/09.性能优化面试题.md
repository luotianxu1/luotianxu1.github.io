---
title: 性能优化面试题
icon: markdown
order: 9
date: 2023-02-17
category:
    - 面试
tag:
    - 性能优化
---

## 1.tree shaking

中文（摇树），`webpack`构建优化中重要一环。摇树用于清除我们项目中的一些无用代码，它依赖于ES中的模块语法。

比如日常使用`lodash`的时候

```js
import _ from 'lodash'
```

如果如上引用`lodash`库，在构建包的时候是会把整个`lodash`包打入到我们的`bundle`包中的。

```js
import _isEmpty from 'lodash/isEmpty';
```

如果如上引用`lodash`库，在构建包的时候只会把`isEmpty`这个方法抽离出来再打入到我们的`bundle`包中。这样的化就会大大减少我们包的`size`。所以在日常引用第三方库的时候，需要注意导入的方式。

在`webpack4.x` 中默认对`tree-shaking`进行了支持

## 2.split chunks

在没配置任何东西的情况下，`webpack 4` 就智能的帮你做了代码分包。入口文件依赖的文件都被打包进了`main.js`，那些大于 30kb 的第三方包，如：`echarts`、`xlsx`、`dropzone`等都被单独打包成了一个个独立 `bundle`。
其它被我们设置了异步加载的页面或者组件变成了一个个`chunk`，也就是被打包成独立的`bundle`。
它内置的代码分割策略是这样的：

- 新的 `chunk` 是否被共享或者是来自 `node_modules` 的模块
- 新的 `chunk` 体积在压缩之前是否大于 30kb
- 按需加载 `chunk` 的并发请求数量小于等于 5 个
- 页面初始加载时的并发请求数量小于等于 3 个

大家可以根据自己的项目环境来更改配置。配置代码如下：

```js
splitChunks({
  cacheGroups: {
    vendors: {
      name: `chunk-vendors`,
      test: /[\\/]node_modules[\\/]/,
      priority: -10,
      chunks: 'initial',
    },
    dll: {
      name: `chunk-dll`,
      test: /[\\/]bizcharts|[\\/]\@antv[\\/]data-set/,
      priority: 15,
      chunks: 'all',
      reuseExistingChunk: true
    },
    common: {
      name: `chunk-common`,
      minChunks: 2,
      priority: -20,
      chunks: 'all',
      reuseExistingChunk: true
    },
  }
})
```

没有使用webpack4.x版本的项目，依然可以通过按需加载的形式进行分包，使得我们的包分散开，提升加载性能。

## 3.gzip

服务端配置gzip压缩后可大大缩减资源大小。
Nginx配置方式

```js
http {
  gzip on;
  gzip_buffers 32 4K;
  gzip_comp_level 6;
  gzip_min_length 100;
  gzip_types application/javascript text/css text/xml;
  gzip_disable "MSIE [1-6]\.";
  gzip_vary on;
}
```

## 4.图片压缩

开发中比较重要的一个环节，我司自己的图床工具是自带压缩功能的，压缩后直接上传到CDN上。
如果公司没有图床工具，我们该如何压缩图片呢？我推荐几种我常用的方式

- 智图压缩 (百度很难搜到官网了，免费、批量、好用)
- tinypng(免费、批量、速度块)
- fireworks工具压缩像素点和尺寸 (自己动手，掌握尺度)
- 找UI压缩后发给你

图片压缩是常用的手法，因为设备像素点的关系，UI给予的图片一般都是 x2，x4的，所以压缩就非常有必要。

## 5.图片分割

如果页面中有一张效果图，比如真机渲染图，UI手拿着刀不让你压缩。这时候不妨考虑一下分割图片。
建议单张土图片的大小不要超过100k，我们在分割完图片后，通过布局再拼接在一起。可以图片加载效率。
这里注意一点，分割后的每张图片一定要给height，否则网速慢的情况下样式会塌陷。

## 6.sprite

南方叫精灵图，北方叫雪碧图。这个现象就很有趣。
在网站中有很多小图片的时候，一定要把这些小图片合并为一张大的图片，然后通过background分割到需要展示的图片。
这样的好处是什么呢？先来普及一个规则
浏览器请求资源的时候，同源域名请求资源的时候有最大并发限制，chrome为6个，就比如你的页面上有10个相同CDN域名小图片，那么需要发起10次请求去拉取，分两次并发。第一次并发请求回来后，发起第二次并发。
如果你把10个小图片合并为一张大图片的画，那么只用一次请求即可拉取下来10个小图片的资源。减少服务器压力，减少并发，减少请求次数。

## 7.CDN

### CDN 的概念

CDN(Content Delivery Network,内容分发网络)是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。典型的 CDN 系统由下面三个部分组成：

- 分发服务系统：最基本的工作单元就是 Cache 设备，cache(边缘 cache)负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 cach 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cach 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。
- 负载均衡系统：主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡(GSLB)和本地负载均衡(SLB)。全局负载均衡主要根据用户就近性原侧，通过对每个服务节点进行“最优”判断，确定向用户提供服务的 c3che 的物理位置。本地负载均衡主要负责节点内部的设备负载均衡
- 运营管理系统：运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。

### CDN 的作用

CDN 一般会用来托管 Web 资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用 CDN 来加速这些资源的访问。

- 在性能方面，引入 CDN 的作用在于：
  - 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快
  - 部分资源请求分配给了 CDN,减少了服务器的负载
- 在安全方面，CDN 有助于防御 DDoS、MITM 等网络攻击：
  - 针对 DDoS:通过监控分析异常流量，限制其请求频率
  - 针对 MlTM:从源服务器到 CDN 节点到 ISP(Internet Service Provider),全链路 HTTPS 通信

除此之外，CDN 作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。

### CDN 的原理

- 用户未使用 CDN 缓存资源的过程：

  - 1.浏览器通过 DNS 对域名进行解析（就是上面的 DNS 解析过程），依次得到此域名对应的 IP 地址
  - 2.浏览器根据得到的 P 地址，向域名的服务主机发送数据请求
  - 3.服务器向浏览器返回响应数据

- 用户使用 CDN 缓存资源的过程：
  - 1.对于点击的数据的 URL,经过本地 DNS 系统的解析，发现该 URL 对应的是一个 CDN 专用的 DNS 服务器，DNS 系统就会将域名解析权交给 CNAME 指向的 CDN 专用的 DNS 服务器。
  - 2.CND 专用 DNS 服务器将 CND 的全局负载均衡设备 P 地返 ▣ 给用户
  - 3.用户向 CDN 的全局负载均衡设备发起数据请求
  - 4.CDN 的全局负载均衡设备根据用户的 P 地址，以及用户请求的内容 URL,选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求
  - 5.区域负载均衡设备选择一台合适的缓存服务器来提供服务，将孩缓存服务器的 P 地返回给全局负载均衡设备
  - 6.全局负载均衡设备把服务器的 P 地返回给用户
  - 7.用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。

如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以
此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。

### CDN 的使用场景

- 使用第三方的 CDN 服务：如果想要开源一些项目，可以使用第三方的 CDN 服务
- 使用 CDN 进行静态资源的缓存：将自己网站的静态资源放在 CDN 上，比如 js、cSsS、图片等。可以将整个项目放在 CDN 上，完成一键部署。
- 直播传送：直播本质上是使用流媒体进行传送，CDN 也是支持流媒体传送的，所以直播完全可以使用 CDN 来提高访方问速度。CDN 在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。

## 8.懒加载

### 懒加载的概念

赖加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那部分图片数据，这样就浪费了性能。

如果使用图片的赖勋加我就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。

### 懒加载的特点

- 减少无用资源的加载：使用赖加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。
- 提升用户体验：如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用赖加载就能大大的提高用户体验。
- 防止加载过多图片而影响其他资源文件的加载：会影响网站应用的正常使用。

### 赖加载的实现原理

图片的加载是由 src 引起的，当对 src 赋值时，浏览器就会请求图片资源。根据这个原理，我们使用 HTML5 的 data-xxx 属性来储存图片的路径，在需要加载图片的时候，将 data-xxx 中图片的路径赋值给 src,这样就实现了图片的按需加载，即赖加载。

注意：data-Xx 中的 xXx 可以自定义，这里我们使用 data-src 来定义。

赖加载的实现重，点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。
使用原生 JavaScript 实现赖加载：

```html
<div class="container">
    <img src="loading.gif" data-src="pic.png" />
    <img src="loading.gif" data-src="pic.png" />
    <img src="loading.gif" data-src="pic.png" />
    <img src="loading.gif" data-src="pic.png" />
    <img src="loading.gif" data-src="pic.png" />
    <img src="loading.gif" data-src="pic.png" />
</div>
<script>
    var imgs = document.querySelectorAl1('img');
    function lozyLoad(){
    var scrollTop =  document.body.scrollTop || document.documentElement.scrollTop;
    var winHeight=window.innerHeight;
    for(var i=0;i imgs.length;i++){
        if(imgs[i].offsetTop scrollTop winHeight ) {
            imgs[i].src imgs[i].getAttribute('data-src');
            window.onscroll lozyLoad();
        }
    }
</script>
```

### 懒加载与预加载的区别

这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预动加载侧会增加服务器前端压力。

- 懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。赖加载的实现原理是，将页面上的图片的src属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的src属性，以此来实现图片的延迟加载。
- 预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。通过预动加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用js中的image对象，通过为image对象来设置scr属性，来实现图片的预动加载。

## 回流与重绘的概念及触发条件

(1)回流

当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为回流。

下面这些操作会导致回流：

- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 激活CSS伪类
- 查询某些属性或者调用某些方法
- 添加或者删除可见的DOM元素

在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DO元素重新排列，它的影响范围有两种：

- 全局范围：从根节点开始，对整个渲染树进行重新布局
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局

(2)重绘

当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是重绘。

下面这些操作会导致重绘：

- color、,background相关属性：background-color、background-.image等
- outline相关属性：outline-color、outline-width、text-decoration
- border-radius、visibility、box-shadow

注意：当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。

## 如何避免回流与重绘？

减少回流与重绘的措施：

- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用table布局，一个小的改动可能会使整个table进行重新布局
- 使用CSS的表达式
- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 使用absolute或者fixed,使元素脱离文档流，这样他们发生变化就不会影响其他元素
- 避免频繁操作DOM,可以创建一个文档片段documentFragment,在它上面应用所有DOM操作，最后再把它添加到文档中
- 将元素先设置display:none,操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。

浏览器针对页面的回流与重绘，进行了自身的优化一渲染队列

浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。
上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

## 如何优化动画？

对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM,就就会导致页面的性能问题，我们可以将动画的position,属性设置为absolute或者fixed,将动画脱离文档流，这样他的回流就不会影响到页面了。

## 如何对项目中的图片进行优化？

- 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用CSS去代替。
- 对于移动端来说，屏幕完度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用CDN加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
- 小图使用base64格式
- 将多个图标文件整合到一张图片中（雪碧图）
- 选择正确的图片格式：
  - 对于能够显示WebP格式的浏览器尽量使用WebP格式。因为WebP格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
  - 小图使用PNG,其实对于大部分图标这类图片，完全可以使用SVG代替
  - 照片使用JPEG

## 浏览器渲染优化

- 针对JavaScript:JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：
  - 尽量将JavaScript文件放在body的最后
  - body中间尽量不要写`<script>`标签
  - `<script>`标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用async属性和defer属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析(尽量使用异步加载)。三者的区别如下：
    - script立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
    - async是在下载完成，之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；
    - dfer是在下载完成之后，立即异步加载。加载好后，如果DOM树还没构建好，则先等DOM
树解析好再执行；如果DOM树已经准备好，则立即执行。多个带dfr属性的标签，按照顺序执
行。
- 针对css:使用CSS有三种方式：使用Iink、@import、.内联样式，其中ink和@import都是导入外部样式。它们之间的区别：
  - `link:`浏览器会派发一个新等线程HTTP线程去加载资源文件，与此比同时GU渲染线程会继续向下渲染代码
  - `@import:GUI`渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染阻碍浏览器渲染
  - `style:GUI`直接渲染

外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。

所以，在开发过程中，导入外部样式使用ink,而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。

- 针对DOM树、CSSOM树：

  - HTML文件的代码层级尽量不要太深
  - 使用语义化的标签，来避免不标准语义化的特殊处理
  - 减少CSSD代码的层级，因为选择器是从左向右进行解析的

- 减少回流与重绘：
  - 操作DOM时，尽量在低层级的DOM节点进行操作
  - 不要使用table布局，一个小的改动可能会使整个tablej进行重新布局
  - 使用CSS的表达式
  - 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
  - 使用absolute或者fixed,使元素脱离文档流，这样他们发生变化就不会影响其他元素
  - 避免频繁操作DOM,可以创建一个文档片段documentFragment,在它上面应用所有DOM操作，最后再把它添加到文档中
  - 将元素先设置display:none,操作结束后再把它显示出来。因为在display属性为none的元素上进的DOM操作不会引发回流和重绘。
  - 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。

浏览器针对页面的回流与重绘，进行了自身的优化一渲染队列

浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。

将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。

## 浏览器缓存策略

强缓存（本地缓存）、协商缓存（弱缓存）
强缓存： 不发请求，直接使用缓存里的内容，浏览器把 JS，CSS，image 等存到内存中，下次用户直接从内存中取，提高性能。
协商缓存： 需要向后台发请求通过判断来决定是否使用协商缓存，如果请求内容没有改变，则返回 304，浏览器就用缓存里的内容。
强缓存的触发：
HTTP1.0: 事件戳响应表头
HTTP1.1：Cache-Control 响应表头
协商缓存触发：
HTTP1.0：请求头:if-modified-since 响应头:last-modified
HTTP1.1: 请求头：if-none-match 响应头：Etag

## Vue 性能优化

- 编码阶段
  - 尽量减少data中的数据，data中的数据都会增加getter和setter,会收集对应的watcher
  - v-if和v-for不能连用
  - 如果需要使用v-o给每项元素绑定事件时使用事件代理
  - SPA页面采用keep-alive缓存组件
  - 在更多的情况下，使用v-i替代v-show
  - key保证唯一
  - 使用略由懒加载、异步组件
  - 防抖、节流
  - 第三方模块按需导入
  - 长列表滚动到可视区域动态加载
  - 图片懒加载
- SEO优化
  - 预渲染
  - 服务端渲染SSR
- 打包优化
  - 压缩代码
  - Tree Shaking/Scope Hoisting
  - 使用cdn加载第三方模块
  - 多线程打包happypack
  - splitChunks:抽离公共文件
  - sourceMap优化
- 用户体验
  - 骨架屏
  - PWA
  - 还可以使用缓存（客户端缓存、服务端缓存）优化、服务端开启gZ压缩等
